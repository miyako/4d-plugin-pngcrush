/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Pngcrush
 #	author : miyako
 #	2016/04/30
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
// --- Pngcrush

		case 1 :
			Pngcrush(pResult, pParams);
			break;

	}
}

#pragma mark -

void pngcrush_write_png(png_structp png_ptr, png_bytep data, png_size_t length)
{
	PNGOutDataPtr pngOut = (PNGOutDataPtr)png_get_io_ptr(png_ptr);
	
	if(pngOut->last_trial)
	{
		pngOut->blob->addBytes((const uint8_t *)data, (uint32_t)length);
	}
	pngOut->len += length;
}

static void pngcrush_cexcept_error(png_structp png_ptr, png_const_charp error_msg)
{
	throw std::invalid_argument(error_msg);
}

void pngcrush_error(png_structp png_ptr, png_const_charp error_msg)
{
	throw std::invalid_argument(error_msg);
}

void pngcrush_warning(png_structp png_ptr, png_const_charp warning_msg)
{
	printf("%s", warning_msg);
}

void pngcrush_read_png(png_structp png_ptr, png_bytep data, png_size_t length)
{
	PNGDataPtr dataptr = (PNGDataPtr)png_get_io_ptr(png_ptr);
	png_uint_32 i;
	
	if (length <= dataptr->len)
	{
		for (i = 0; i < length; i++)
			data[i] = dataptr->p[i];
		
		dataptr->p += length;
		dataptr->len -= length;
	}
}

static void pngcrush_flush(png_structp png_ptr)
{

}

png_uint_32 PNGAPI pngcrush_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)
{
	png_uint_32 uval = png_get_uint_32(buf);
	
	if (uval > PNG_UINT_31_MAX)
		throw std::invalid_argument("PNG unsigned integer out of range");
	
	return (uval);
}

void pngcrush_examine_pixels_fn(png_structp png_ptr, png_row_infop row_info, png_bytep data)
{
	png_pixelp pixel = (png_pixelp)png_get_user_transform_ptr(png_ptr);
	
	if (pixel->blacken == 1 || pixel->make_gray == 1 || pixel->make_opaque == 1)
	{
		/* Check if there are any fully transparent pixels.  If one is found,
		 * without the underlying color already black, set blacken==2. If the
		 * PNG colortype does not support an alpha channel, set blacken==3.
		 *
		 * Check if there are any transparent pixels.  If one is found,
		 * set make_opaque==2. If the PNG colortype does not support an alpha
		 * channel, set make_opaque==3.
		 *
		 * Check if there are any non-gray pixels.  If one is found,
		 * set make_gray == 2. If the PNG colortype is already gray, set
		 * make_gray = 3.
		 *
		 * Check if any 16-bit pixels do not have identical high and low
		 * bytes.  If one is found, set make_8_bit == 2. If the PNG bit_depth
		 * is not 16-bits, set make_8_bit = 3.
		 *
		 * Find the maximum palette entry present in the IDAT chunks of
		 * an indexed PNG.
		 *
		 */
		
		int i;
		
		if (row_info->color_type < 4)
		{
			pixel->blacken = 3;  /* It doesn't have an alpha channel */
			/* To do: check if tRNS chunk can be removed from color type 0 or 2 */
			pixel->make_opaque = 3;
		}
		
		if (row_info->color_type == 0 || row_info->color_type == 4)
			pixel->make_gray = 3; /* It's already gray! */
		
		if (row_info->color_type == 3)
			pixel->make_gray = 3; /* Don't change indexed PNG */
		
		if (row_info->bit_depth < 16)
			pixel->make_8_bit = 3;
		
		i = (int) row_info->rowbytes-1;
		
		if ((row_info->color_type == 2 || row_info->color_type == 6) &&
				pixel->make_gray == 1) /* RGB */
		{
			if (row_info->bit_depth == 8)
			{
				int incr=3;
				if (row_info->color_type == 6)
				{
					incr=4;
					i--;
				}
				for ( ; i > 0 ; )
				{
					if (data[i] != data[i-1] || data[i] != data[i-2])
					{
						pixel->make_gray = 2;
					}
					
					i-=incr;
				}
			}
			
			else /* bit depth == 16 */
			{
				int incr = 6;
				if (row_info->color_type == 6)
				{
					incr = 8;
					i-=2;
				}
				for ( ; i > 0 ; )
				{
					if (data[i] != data[i-2] || data[i] != data[i-4] ||
							data[i-1] != data[i-3] || data[i-1] != data[i-5])
					{
						pixel->make_gray = 2;
					}
					i-=incr;
				}
			}
		}
		
		else if (row_info->color_type == 4 && (pixel->blacken == 1 ||
																					 pixel->make_opaque == 1)) /* GA */
		{
			i = (int) row_info->rowbytes-1;
			
			if (row_info->bit_depth == 8)
			{
				for ( ; i > 0 ; )
				{
					if (pixel->blacken == 1 && data[i] == 0 &&  data[i-1] != 0)
					{
						pixel->blacken = 2;
					}
					
					if (pixel->make_opaque == 1 && data[i] != 255)
					{
						pixel->make_opaque = 2;
					}
					i-=2;
				}
			}
			
			else /* bit depth == 16 */
			{
				for ( ; i > 0 ; )
				{
					if (pixel->blacken == 1 && (data[i] == 0 && data[i-1] == 0) &&
							(data[i-2] != 0 || data[i-3] != 0))
					{
						pixel->blacken = 2;
					}
					
					if (pixel->make_opaque == 1 && (data[i] != 255 || data[i-1] != 255))
					{
						pixel->make_opaque = 2;
					}
					i-=4;
				}
			}
		}
		
		/* color_type == 6, RGBA */
		if (row_info->color_type == 6 && (pixel->blacken == 1 || pixel->make_gray == 1 ||
																			pixel->make_opaque == 1))
		{
			i = (int) row_info->rowbytes-1;
			
			if (row_info->bit_depth == 8)
			{
				for ( ; i > 0 ; )
				{
					if (pixel->blacken == 1 && data[i] == 0 &&
							(data[i-1] != 0 || data[i-2] != 0 || data[i-3] != 0))
					{
						pixel->blacken = 2;
					}
					
					if (pixel->make_gray == 1 &&
							(data[i-1] != data[i-2] || data[i-1] != data[i-3]))
					{
						pixel->make_gray = 2;
					}
					
					if (pixel->make_opaque == 1 && data[i] != 255)
					{
						pixel->make_opaque = 2;
					}
					
					i-=4;
				}
			}
			
			else /* bit depth == 16 */
			{
				for ( ; i > 0 ; )
				{
					if (pixel->blacken == 1 && (data[i] == 0 && data[i-1]== 0) &&
							(data[i-2] != 0 || data[i-3] != 0 || data[i-4] != 0 ||
							 data[i-5] != 0 || data[i-6] != 0 || data[i-7] != 0))
					{
						pixel->blacken = 2;
					}
					
					if (pixel->make_gray == 1 &&
							(data[i-2] != data[i-4] || data[i-2] != data[i-6] ||
							 data[i-3] != data[i-5] || data[i-3] != data[i-7]))
					{
						pixel->make_gray = 2;
					}
					
					if (pixel->make_opaque == 1 && (data[i] != 255 || data[i-1] != 255))
					{
						pixel->make_opaque = 2;
					}
					
					i-=8;
				}
			}
		}
	}
	
	if (pixel->make_8_bit == 1)
	{
		int i;
		i = (int) row_info->rowbytes-1;
		
		if (row_info->color_type == 0)
		{
			for ( ; i > 0 ; )
			{
				if (data[i] != data[i-1])
					pixel->make_8_bit = 2;
				i-=2;
			}
		}
		
		if (row_info->color_type == 2)
		{
			for ( ; i > 0 ; )
			{
				if (data[i] != data[i-1] || data[i-2] != data[i-3] ||
						data[i-4] != data [i-5])
					pixel->make_8_bit = 2;
				i-=6;
			}
		}
		
		if (row_info->color_type == 4)
		{
			for ( ; i > 0 ; )
			{
				if (data[i] != data[i-1] || data[i-2] != data[i-3])
					pixel->make_8_bit = 2;
				i-=4;
			}
		}
		
		if (row_info->color_type == 6)
		{
			for ( ; i > 0 ; )
			{
				if (data[i] != data[i-1] || data[i-2] != data[i-3] ||
						data[i-4] != data [i-5] || data[i-6] != data[i-7])
					pixel->make_8_bit = 2;
				i-=8;
			}
		}
	}
	
	if (pixel->reduce_palette == 1 && row_info->color_type == 3)
	{
		int i;
		i = (int) row_info->rowbytes-1;
		
		for ( ; i > 0 ; i--)
		{
			if (data[i] >= pixel->plte_len)
				pixel->plte_len = data[i] + 1;
		}
	}
}

void PNGCBAPI pngcrush_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
	PNGDataPtr dataptr = (PNGDataPtr)png_get_io_ptr(png_ptr);
	png_uint_32 i;
	
	if (length != 0)
	{
		for (i = 0; i < length; i++)
			data[i] = dataptr->p[i];
		
		dataptr->p += length;
		dataptr->len -= length;
	}
}

void PNGAPI pngcrush_calculate_crc(png_structp png_ptr, png_bytep ptr, png_size_t length, png_uint_32 *pngcrush_crc)
{
	*pngcrush_crc = crc32(*pngcrush_crc, ptr, (uInt)length);
}

void PNGAPI pngcrush_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length, png_uint_32 *pngcrush_crc)
{
	pngcrush_default_read_data(png_ptr, buf, length);
	pngcrush_calculate_crc(png_ptr, buf, length, pngcrush_crc);
}

void PNGAPI pngcrush_reset_crc(png_structp png_ptr, png_uint_32 *pngcrush_crc)
{
	*pngcrush_crc = crc32(0, Z_NULL, 0);
}

int pngcrush_crc_error(png_structrp png_ptr)
{
	png_byte crc_bytes[4];
	png_uint_32 crc;
	int need_crc = 1;
	
	if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)
	{
		if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
				(PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
			need_crc = 0;
	}
	
	else /* critical */
	{
		if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)
			need_crc = 0;
	}
	
#ifdef PNG_IO_STATE_SUPPORTED
	png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;
#endif
	
	/* The chunk CRC must be serialized in a single I/O call. */
	png_read_data(png_ptr, crc_bytes, 4);
	
	if (need_crc != 0)
	{
		crc = png_get_uint_32(crc_bytes);
		return ((int)(crc != png_ptr->crc));
	}
	
	else
		return (0);
}

int pngcrush_crc_finish(png_structrp png_ptr, png_uint_32 skip, png_uint_32 *pngcrush_crc)
{
	/* The size of the local buffer for inflate is a good guess as to a
	 * reasonable size to use for buffering reads from the application.
	 */
	while (skip > 0)
	{
		png_uint_32 len;
		png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];
		
		len = (sizeof tmpbuf);
		if (len > skip)
			len = skip;
		skip -= len;
		
		pngcrush_crc_read(png_ptr, tmpbuf, len, pngcrush_crc);
	}
	
	if (pngcrush_crc_error(png_ptr) != 0)
	{
		if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?
				(png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0 :
				(png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE) != 0)
		{
			//warning
		}
		
//		else
//			throw std::invalid_argument("CRC error");
		
		return (1);
	}
	
	return (0);
}

void pngcrush_transform_pixels_fn(png_structp png_ptr, png_row_infop row_info,
																	png_bytep data)
{
	
	int i;
	png_pixelp pixel = (png_pixelp)png_get_user_transform_ptr(png_ptr);
	
	if (pixel->blacken == 2)
	{
		/* change the underlying color of any fully transparent pixels to black */
		i=(int) row_info->rowbytes-1;
		
		if (row_info->color_type == 4) /* GA */
		{
			if (row_info->bit_depth == 8)
			{
				for ( ; i > 0 ; )
				{
					if (data[i] == 0 &&  data[i-1] != 0)
					{
						data[i-1]=0;
					}
					i-=2;
				}
			}
			
			else /* bit depth == 16 */
			{
				for ( ; i > 0 ; )
				{
					if (data[i] == 0 && data[i-1] == 0)
					{
						data[i-2]=0;
						data[i-3]=0;
					}
					i-=4;
				}
			}
		}
		
		else /* color_type == 6, RGBA */
		{
			if (row_info->bit_depth == 8)
			{
				for ( ; i > 0 ; )
				{
					if (data[i] == 0)
					{
						data[i-1]=0;
						data[i-2]=0;
						data[i-3]=0;
					}
					i-=4;
				}
			}
			
			else /* bit depth == 16 */
			{
				for ( ; i > 0 ; )
				{
					if (data[i] == 0 && data[i-1] == 0)
					{
						data[i-2]=0;
						data[i-3]=0;
						data[i-4]=0;
						data[i-5]=0;
						data[i-6]=0;
						data[i-7]=0;
					}
					i-=8;
				}
			}
		}
	}
}

/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
png_uint_32 pngcrush_get_uint_32(png_bytep buf)
{
	png_uint_32 i = ((png_uint_32) (*buf & 0xff) << 24) +
	(*(buf + 1) << 16) + (*(buf + 2) <<  8) + (*(buf + 3)) ;
	
	return (i);
}

#pragma mark -

void png_skip_chunk(png_structp png_ptr)
{
	png_byte buff[4] = { 0, 0, 0, 0 };
	int ib;
	unsigned long length;
	
	/* read the length field */
	pngcrush_default_read_data(png_ptr, buff, 4);
	length = pngcrush_get_uint_31(png_ptr,buff);
	/* read the chunk name */
	pngcrush_default_read_data(png_ptr, buff, 4);
	
	/* skip the data and CRC */
	for (ib=0; ib<length+4; ib++)
	{
		png_byte junk[1] = { 0 };
		pngcrush_default_read_data(png_ptr, junk, 1);
	}
}

#pragma mark -

png_uint_32 pngcrush_measure_idat(png_structp png_ptr, png_idatp idatp)
{
	png_uint_32 sum_idat_length = 45;
	
	//this is the buffer
	png_byte png_signature[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
	
	//read a few bytes into buffer
	pngcrush_default_read_data(png_ptr, png_signature, 8);
	png_set_sig_bytes(png_ptr, 8);
	
	//check first 8 bytes for png signature
	if (!png_sig_cmp(png_signature, 0, 8))
	{
		//is png
		
		if (idatp->salvage)
		{
#ifdef PNG_CRC_WARN_USE
			png_set_crc_action(png_ptr, PNG_CRC_WARN_USE, PNG_CRC_WARN_USE);
#endif
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
			/* The warning here about deprecated access to png_ptr->zstream
			 * is unavoidable.  This will not work with libpng-1.5.x and later.
			 */
			inflateUndermine(&png_ptr->zstream, 1);
#endif
		}

		for (;;)
		{
			
			png_byte chunk_name[5];
			png_byte chunk_length[4];
			png_byte buff[32];
			png_uint_32 length;
			
			pngcrush_default_read_data(png_ptr, chunk_length, 4);
			length = pngcrush_get_uint_31(png_ptr,chunk_length);
			
			png_uint_32 pngcrush_crc;
			pngcrush_reset_crc(png_ptr, &pngcrush_crc);
			pngcrush_crc_read(png_ptr, chunk_name, 4, &pngcrush_crc);
			chunk_name[4]='\0';
			
			/* Check for valid chunk name [A-Za-z][A-Za-z][A-Z][A-Za-z] */
			if ( (((chunk_name[0] >= PNGCRUSH_a && chunk_name[0] <= PNGCRUSH_z)  ||
						 (chunk_name[0] >= PNGCRUSH_A && chunk_name[0] <= PNGCRUSH_Z)) &&
						((chunk_name[1] >= PNGCRUSH_a && chunk_name[1] <= PNGCRUSH_z)  ||
						 (chunk_name[2] >= PNGCRUSH_A && chunk_name[2] <= PNGCRUSH_Z)) &&
						((chunk_name[2] >= PNGCRUSH_A && chunk_name[2] <= PNGCRUSH_Z)) &&
						((chunk_name[3] >= PNGCRUSH_a && chunk_name[3] <= PNGCRUSH_z)  ||
						 (chunk_name[3] >= PNGCRUSH_A && chunk_name[3] <= PNGCRUSH_Z))))
			{
				//----------------[acTL]
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_acTL)
				{
					idatp->found_acTL_chunk = 1;
				}
				
				//----------------[IDAT]
				//----------------[PLTE]
				if ((pngcrush_get_uint_32(chunk_name) == PNG_UINT_IDAT)
						|| (pngcrush_get_uint_32(chunk_name) == PNG_UINT_PLTE))
				{
					sum_idat_length += (length + 12);
				}
				
				//----------------[CgBI]
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_CgBI)
				{
					idatp->found_CgBI = 1;
					idatp->salvage = 1;//for retry
				}
				
				//----------------[IHDR]
				//----------------[dSIG]
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_IHDR)
				{
					/* get the color type */
					pngcrush_crc_read(png_ptr, buff, 13, &pngcrush_crc);
					length -= 13;
					idatp->input_color_type = buff[9];
				}else if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_dSIG)
				{
					if (idatp->found_any_chunk == 0 && !idatp->all_chunks_are_safe)
					{
						idatp->image_is_immutable = 1;
					}
				}
				else
					idatp->found_any_chunk = 1;
				
				//----------------[gAMA]
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_gAMA)
				{
					idatp->found_gAMA = 1;
				}
				
				//----------------[bKGD]
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_bKGD)
				{
					if (length == 6)
					{
						/* Set found_color_bKGD if the components are different,
						 * so we do not do reduction of color-type from color to gray
						 */
						pngcrush_crc_read(png_ptr, buff, 6, &pngcrush_crc);
						length -= 6;
						if ((buff[0] != buff[2]) && (buff[0] != buff[4]) &&
								(buff[1] != buff[3]) && (buff[0] != buff[5]))
							idatp->found_color_bKGD = 1;
					}
				}
				
				//----------------[cHRM]
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_cHRM)
				{
					idatp->found_cHRM = 1;
				}
				
				//----------------[hIST]
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_hIST)
				{
					idatp->found_hIST = 1;
				}
				
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_iCCP)
				{
					idatp->found_iCCP = 1;
					
					/* Check for bad Photoshop iCCP chunk.  Libpng will reject the
					 * bad chunk because the Adler-32 bytes are missing, but we check
					 * here to see if it's really the sRGB profile, and if so, set the
					 * "intent" flag and gamma so pngcrush will write an sRGB chunk
					 * and a gamma chunk.
					 */
					if (length == 2615)
					{
						pngcrush_crc_read(png_ptr, buff, 22, &pngcrush_crc);
						length -= 22;
						buff[23] = 0;
						if (!strncmp((png_const_charp) buff, "Photoshop ICC profile", 21))
						{
							//Replacing bad Photoshop iCCP chunk with an sRGB chunk
							idatp->image_specified_gamma = 45455L;
							idatp->found_iCCP = 0;
							idatp->found_sRGB = 1;
							idatp->intent = 0;
						}
					}
					/* To do: recognize other sRGB iCCP chunks and replace them with
					 * sRGB chunk
					 */
				}
				
				//----------------[sBIT]
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_sBIT)
				{
					if (length <= 4)
					{
						int i;
						pngcrush_crc_read(png_ptr, buff, length, &pngcrush_crc);
						idatp->found_sBIT_max = 0;
						for (i=length; i; i--)
							if (buff[i] > idatp->found_sBIT_max)
								idatp->found_sBIT_max=buff[i];
						
						if (length > 2)
							if (buff[0] != buff[1] || buff[0] != buff[2])
								idatp->found_sBIT_different_RGB_bits = 1;
						
						idatp->found_sBIT = 1;
						length = 0;
					}
				}
				
				//----------------[tRNS]
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_tRNS)
				{
					idatp->found_tRNS = 1;
				}
				
				pngcrush_crc_finish(png_ptr, length, &pngcrush_crc);
				
				//----------------[IEND]
				if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_IEND)
				{
					break;
				}
			}

		}//for
		
	}//is png

	return sum_idat_length;
}

png_uint_32 measure_idats(std::vector<unsigned char> &pictureData, png_idatp idatp)
{
	png_uint_32 measured_idat_length = 0;
	
	png_structp read_ptr = png_create_read_struct(
		PNG_LIBPNG_VER_STRING,
		(png_voidp) NULL,
		(png_error_ptr) NULL,
		(png_error_ptr) NULL);
	
	if (read_ptr)
	{
		png_infop read_info_ptr = png_create_info_struct(read_ptr);
		if(!read_info_ptr)
		{
			png_destroy_read_struct(&read_ptr, NULL, NULL);
		}else
		{
			png_infop end_info_ptr = png_create_info_struct(read_ptr);
			if(!end_info_ptr)
			{
				png_destroy_read_struct(&read_ptr, &read_info_ptr, NULL);
			}else
			{
				PNGData data;
				data.p = &pictureData[0];
				data.len = pictureData.size();
				png_set_read_fn(read_ptr, (png_voidp) &data, (png_rw_ptr) pngcrush_read_png);				
				png_set_error_fn(read_ptr, NULL, pngcrush_error, pngcrush_warning);
				png_set_sig_bytes(read_ptr, 0);
				try
				{
					measured_idat_length = pngcrush_measure_idat(read_ptr, idatp);
					png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
				}catch(...)
				{
					measured_idat_length = 0;
				}
			}
		}
	}
	return measured_idat_length;
}

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
static /* const */ png_byte chunks_to_ignore[] = {
	
	98,  75,  71 , 68, '\0',  /* bKGD */
	99,  72,  82,  77, '\0',  /* cHRM */
	103,  65,  77,  65, '\0',  /* gAMA */
	104,  73,  83,  84, '\0',  /* hIST */
	105,  67,  67,  80, '\0',  /* iCCP */
	105,  84,  88, 116, '\0',  /* iTXt */
	111,  70,  70, 115, '\0',  /* oFFs */
	112,  67,  65,  76, '\0',  /* pCAL */
	112,  72,  89, 115, '\0',  /* pHYs */
	115,  66,  73,  84, '\0',  /* sBIT */
	115,  67,  65,  76, '\0',  /* sCAL */
	115,  80,  76,  84, '\0',  /* sPLT */
	115,  82,  71,  66, '\0',  /* sRGB */
	115,  84,  69,  82, '\0',  /* sTER */
	116,  69,  88, 116, '\0',  /* tEXt */
	116,  73,  77,  69, '\0',  /* tIME */
	116,  82,  78,  83, '\0',  /* tRNS */
	122,  84,  88, 116, '\0'   /* zTXt */
};
#endif

#pragma mark -

bool getPictureDataForType(PackagePtr pParams, int index, std::vector<unsigned char> &buf, std::string &type)
{
	PA_ErrorCode err = eER_NoErr;
	unsigned i = 0;
	PA_Unistring t;
	std::map<CUTF8String, uint32_t> types;
	PA_Picture picture = *(PA_Picture *)(pParams[index - 1]);
	while (err == eER_NoErr)
	{
		t = PA_GetPictureData(picture, ++i, NULL);
		err = PA_GetLastError();
		if(err == eER_NoErr)
		{
			uint32_t len = (uint32_t)(t.fLength * 4) + sizeof(uint8_t);
			std::vector<uint8_t> u(len);
			PA_ConvertCharsetToCharset(
																 (char *)t.fString,
																 t.fLength * sizeof(PA_Unichar),
																 eVTC_UTF_16,
																 (char *)&u[0],
																 len,
																 eVTC_UTF_8
																 );
			CUTF8String uti;
			uti = CUTF8String((const uint8_t *)&u[0]);
			CUTF8String typestring;
			size_t pos, found;
			found = 0;
			for(pos = uti.find(';'); pos != CUTF8String::npos; pos = uti.find(';', found))
			{
				typestring = uti.substr(found, pos-found);
				found = pos + 1;
				types.insert(std::map<CUTF8String, uint32_t>::value_type(typestring, i));
			}
			typestring = uti.substr(found, uti.length()-found);
			types.insert(std::map<CUTF8String, uint32_t>::value_type(typestring, i));
		}
	}
	std::map<CUTF8String, uint32_t>::iterator itr;
	itr = types.find((const uint8_t *)type.c_str());
	if (itr != types.end())
	{
		uint32_t pos = itr->second;
		PA_Handle h = PA_NewHandle(0);
		err = eER_NoErr;
		PA_GetPictureData(picture, pos, h);
		err = PA_GetLastError();
		if(err == eER_NoErr)
		{
			unsigned long insize = PA_GetHandleSize(h);
			buf.resize(insize);
			memcpy(&buf[0], (const void *)PA_LockHandle(h), insize);
			PA_UnlockHandle(h);
			PA_DisposeHandle(h);
			return true;
		}
	}
	return false;
}

#pragma mark -

void pngcrush_setup_methods(std::vector<int> &try_method, std::vector<int> &fm, std::vector<int> &lv, std::vector<int> &zs)
{
	try_method.resize(MAX_METHODSP1);
	fm.resize(MAX_METHODSP1);
	lv.resize(MAX_METHODSP1);
	zs.resize(MAX_METHODSP1);

	for (int i = 0; i < MAX_METHODS; ++i)
	{
		try_method[i] = 1;  /* 1 means do not try this method */
		fm[i] = 5; lv[i] = 9; zs[i] = 1;  /* default:  method 136 */
	}
	for (int i = 0; i <= DEFAULT_METHODS; ++i)
	{
		try_method[i] = 0;
	}
	fm[0] = 0; lv[0] = 0; zs[0] = 0;   /* method  0 == uncompressed */
	fm[1] = 0; lv[1] = 4; zs[1] = 0;   /* method  1 == method  53 */
	fm[2] = 1; lv[2] = 4; zs[2] = 0;   /* method  2 == method  54 */
	lv[3] = 4;              /* method  3 == method  64 */
	fm[4] = 0;                         /* method  4 == method 119 */
	fm[5] = 1;            zs[5] = 0;   /* method  5 == method 114 */
	zs[6] = 0;   /* method  6 == method 118 */
	fm[7] = 0;            zs[7] = 0;   /* method  7 == method 113 */
	fm[8] = 1;                         /* method  8 == method 120 */
	lv[9] = 2; zs[9] = 2;   /* method  9 == method  16 */
	/* method 10 == method 124 */
	/* methods 11 through 16
	 *
	 * [strategy 2 (Z_HUFFMAN_ONLY) is independent of zlib compression level]
	 */
	int method = 11;
	int lev, strat, filt;
	for (filt = 0; filt <= 5; filt++)
	{
		fm[method] = filt;
		lv[method] = 2;
		zs[method] = 2;
		method++;
	}
	/*
	 * methods 17 through 136 (10*2*6 = 120)
	 */
	for (lev = 1; lev <= 9; lev++)
	{
		for (strat = 0; strat <= 1; strat++)
		{
			for (filt = 0; filt <= 5; filt++)
			{
				fm[method] = filt;
				lv[method] = lev;
				zs[method] = strat;
				method++;
			}
		}
	}
#ifdef Z_RLE
	/* methods 137 through 148
	 *
	 * [strategy 3 (Z_RLE) is mostly independent of level; 1-3 and 4-9 are
	 * same]
	 */
	for (filt = 0; filt <= 5; filt++)
	{
		fm[method] = filt;
		lv[method] = 1;
		zs[method] = 3;
		method++;
	}
	for (filt = 0; filt <= 5; filt++)
	{
		fm[method] = filt;
		lv[method] = 4;
		zs[method] = 3;
		method++;
	}
#endif /* Z_RLE */
	for (strat = 0; strat <= 1; strat++)
	{
		for (filt = 0; filt <= 5; filt++)
		{
			fm[method] = filt;
			lv[method] = 0;
			zs[method] = strat;
			method++;
		}
	}
}

#pragma mark -

void Pngcrush(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_LONGINT Param2;
	C_BLOB png;
	
	Param2.fromParamAtIndex(pParams, 2);
	
	/* get png data */
	std::vector<unsigned char>pictureData;
	std::string type(".png");
	if(getPictureDataForType(pParams, 1, pictureData, type))
	{
		float t_start = (TIME_T) clock();
		float t_stop = 0;
		
		png_idat idat;
		memset(&idat, 0x00, sizeof(idat));

		png_uint_32 measured_idat_length = measure_idats(pictureData, &idat);
		
		if(idat.found_CgBI)
			measured_idat_length = measure_idats(pictureData, &idat);//-fix

		if(measured_idat_length)
		{
			
			std::vector<int>try_method;
			std::vector<int>fm;
			std::vector<int>lv;
			std::vector<int>zs;
			
			pngcrush_setup_methods(try_method, fm, lv, zs);
			
			int i;
			int trial;
			int last_trial = 0;
			int found_IDAT;
			int force = 1;
			int z_strategy;
			int filter_type, zlib_level;
			int final_method = 0;
			int no_limits = 0;
			int make_8_bit = 1;
			int make_gray = 0;
			int make_opaque = 0;
			int blacken = 0;
			int save_apng_chunks = 0;
//			int premultiply = 0;
			int force_output_bit_depth = 0;
//			int found_acTL_chunk = 0;
			int have_bkgd = 0;
//			int input_color_type = 3;
			png_uint_16 bkgd_red = 0;
			png_uint_16 bkgd_green = 0;
			png_uint_16 bkgd_blue = 0;
			png_byte bkgd_index = 0;
			static int specified_gamma = 0;
//			static int image_specified_gamma = 0;
			static int force_specified_gamma = 0;
			png_fixed_point file_gamma = 0;
			int double_gamma = 0;
			int iccp_length = 0;
			int resolution = 0;
			int have_trns = 0;
			png_uint_16 trns_index = 0;
			png_uint_16 trns_red = 0;
			png_uint_16 trns_green = 0;
			png_uint_16 trns_blue = 0;
			png_uint_16 trns_gray = 0;
			png_bytep trans;
			int num_trans;
			png_color_16p trans_values;
			int ia;
			png_byte trns_array[256];
			png_byte trans_in[256];
			int num_palette = 0;
			int input_bit_depth = 0;
			char *iccp_text = NULL;
			char iccp_name[80];
			png_colorp palette;
			int text_inputs = 0;
			char text_keyword[11*80+1];
			int text_where[10];
			char text_lang[881];
			char text_lang_key[881];
			char text_text[11*STR_BUF_SIZE+1];
			int text_compression[10];
			int ster_mode = -1;
			int speed = 0;
			int compression_mem_level = 9;
			int compression_window;
			png_alloc_size_t max_bytes;
//			png_uint_32 max_idat_size = MAX_IDAT_SIZE;
			int default_compression_window = 15;
			int force_compression_window = 0;
			png_bytep row_buf;
			int num_pass;
			float t_misc = 0;
			int pass;
			png_uint_32 y;
			float t_decode = 0;
			float t_encode = 0;
			int best_of_three = 1;
			int bail = 0;
			png_uint_32 pngcrush_write_byte_count;
			png_uint_32 pngcrush_best_byte_count=0xffffffff;
			png_uint_32 idat_length[MAX_METHODSP1];
			idat_length[0] = measured_idat_length;
			
			if (!idat.image_is_immutable)
			{
				int output_color_type = 8;
				int output_bit_depth = 0;
//				int compression_window = 15;

				/*
				 * From the PNG spec, various dependencies among chunk types
				 *   must be accounted for during any reduction of color type
				 *   or bit depth:
				 *
				 * IHDR valid bit depth depends on color type
				 *   valid filter type depends on color type (for MNG extensions)
				 * tRNS depends on color type
				 *   depends on num_palette for color type 3 (palette)
				 * iCCP valid profile depends on color type
				 * sBIT depends on color type and bit depth
				 * bKGD depends on color type and bit depth
				 *
				 */
				//----------------[HIST]; hIST depends on num_palette
				int reduce_palette = 1;
				int plte_len = -1;
				if(idat.input_color_type == 3)
				{
					if ((idat.found_hIST && (!(Param2.getIntValue() & PNG_REMOVE_HIST))) || idat.found_acTL_chunk == 1)
					{
						printf("%s", "Cannot reduce palette length when hIST or acTL chunk is present");
						reduce_palette = 0;
						plte_len = -1;
					}
					else
					{
						try_method[0] = 0;
						plte_len = 0;
					}
				}
				for (trial = 0; trial <= MAX_METHODS; ++trial)
				{
					PA_YieldAbsolute();
					last_trial = (trial == MAX_METHODS);
					pngcrush_write_byte_count = 0;
					found_IDAT = 0;
					if (trial != 0)
					{
						idat_length[trial] = (png_uint_32) 0xffffffff;
					}/* [0] contains the measured size */
					/* this part of if-block is for final write-the-best-file iteration */
					if (trial == MAX_METHODS)
					{
						png_uint_32 best_length;
						int j;
						/* check lengths */
						int best = 0;
						best_length = (png_uint_32) 0xffffffff;
						for (j = 0; j < MAX_METHODS; j++)
						{
							if (best == 0 && best_length == idat_length[j])
							{
								/* If no change, report the first match */
								best = j;
							}
							if ((force == 0 || j != 0) && best_length > idat_length[j])
							{
								best_length = idat_length[j];
								best = j;
							}
						}
						if (idat.image_is_immutable || (idat_length[best] == idat_length[0]))
						{
							/* just copy input to output */
							PA_Picture picture = PA_CreatePicture((void *)&pictureData[0], pictureData.size());
							*(PA_Picture*) pResult = picture;
							break;
						}
						/* get the bast method and zlib level */
						filter_type = fm[best];
						zlib_level = lv[best];
						if (zs[best] == 1)
							z_strategy = Z_FILTERED;
						else if (zs[best] == 2)
							z_strategy = Z_HUFFMAN_ONLY;

						else if (zs[best] == 3)
							z_strategy = Z_RLE;

						else /* if (zs[best] == 0) */
							z_strategy = Z_DEFAULT_STRATEGY;
					}
					else /* Trial < MAX_METHODS */
					{
						if (trial > 2 && trial < 5 && idat_length[trial - 1]
								< idat_length[best_of_three])
							best_of_three = trial - 1;
						
						if (try_method[trial])
						{
							continue;
						}
						if ((trial == 4 || trial == 7) && best_of_three != 1)
						{
							continue;
						}
						if ((trial == 5 || trial == 8) && best_of_three != 2)
						{
							continue;
						}
						if ((trial == 6 || trial == 9 || trial == 10)
								&& best_of_three != 3)
						{
							continue;
						}
					
						filter_type = fm[trial];
						zlib_level = lv[trial];
						if (zs[trial] == 1)
							z_strategy = Z_FILTERED;
						else if (zs[trial] == 2)
							z_strategy = Z_HUFFMAN_ONLY;

						else if (zs[trial] == 3)
							z_strategy = Z_RLE;

						else /* if (zs[trial] == 0) */
							z_strategy = Z_DEFAULT_STRATEGY;
						final_method = trial;
					}
					png_structp read_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, (png_voidp) NULL, (png_error_ptr) pngcrush_cexcept_error, (png_error_ptr) pngcrush_warning);
					if(read_ptr)
					{
						png_set_benign_errors(read_ptr, 1);
						if (no_limits == 0)
						{
							png_set_user_limits(read_ptr, 500000L, 500000L);
							png_set_chunk_cache_max(read_ptr, 500);
							png_set_chunk_malloc_max(read_ptr, 2000000L);
						}
						if (idat.salvage)
						{
							png_set_option(read_ptr, PNG_MAXIMUM_INFLATE_WINDOW, PNG_OPTION_ON);
						}
						/* Change the underlying color of any fully transparent pixel to black.
						 * Remove the alpha channel from any fully-opaque image.
						 * Change any all-gray image to a gray colortype.
						 * Reduce 16-bit image to 8-bit if possible without loss.
						 */
						png_pixel pixel;
						pixel.blacken = blacken;
						pixel.make_gray = make_gray;
						pixel.make_opaque = make_opaque;
						pixel.make_8_bit = make_8_bit;
						pixel.reduce_palette = reduce_palette;
						pixel.plte_len = plte_len;
						int user_depth = 0, user_channels = 0;
						if (trial == 0
								&& (blacken == 1
								|| make_gray == 1
								|| make_opaque == 1
								|| make_8_bit == 1
								|| reduce_palette == 1))
						{
							png_set_user_transform_info(read_ptr, &pixel, user_depth, user_channels);
							png_set_read_user_transform_fn(read_ptr, pngcrush_examine_pixels_fn);
						}
						if (last_trial == 0)
						{
							png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_NEVER, (png_bytep) NULL, 0);
							png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_NEVER, chunks_to_ignore, sizeof (chunks_to_ignore)/5);
						}
						png_structp write_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, (png_voidp) NULL, (png_error_ptr) pngcrush_error, (png_error_ptr) pngcrush_warning);
						if(write_ptr)
						{
							png_infop read_info_ptr = png_create_info_struct(read_ptr);
							if(!read_info_ptr)
							{
								break;
							}else
							{
								png_infop end_info_ptr = png_create_info_struct(read_ptr);
								if(!end_info_ptr)
								{
									png_destroy_read_struct(&read_ptr, &read_info_ptr, NULL);
									break;
								}else
								{
									png_infop write_info_ptr = png_create_info_struct(write_ptr);
									if(!write_info_ptr)
									{
										png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
										break;
									}else
									{
										png_infop write_end_info_ptr = png_create_info_struct(write_ptr);
										if(!write_end_info_ptr)
										{
											png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
											png_destroy_write_struct(&write_ptr, &write_info_ptr);
											break;
										}else
										{
											PNGOutData pngOut;
											pngOut.blob = &png;
											pngOut.len = 0;
											pngOut.last_trial = last_trial;
											png_set_write_fn(write_ptr, (png_voidp)&pngOut, pngcrush_write_png, pngcrush_flush);
											PNGData pngIn;
											pngIn.p = &pictureData[0];
											pngIn.len = pictureData.size();
											png_set_read_fn(read_ptr, (png_voidp) &pngIn, (png_rw_ptr) pngcrush_read_png);

											/* We don't need to check CRC's because they were already
											 checked in the pngcrush_measure_idat function */
											png_set_crc_action(read_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);
											
											if (last_trial == 0)
											{
											/* Only calculate CRC while writing the final output */
												png_set_crc_action(write_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);
											}
											/* Only run this test (new in libpng-1.5.10) during the
											 * 0th and last trial
											 */
											if ((idat.input_color_type == 3) &&
													((last_trial && pixel.reduce_palette == 0) ||
													 (trial == 0 && pixel.reduce_palette == 1)))
											{
												png_set_check_for_invalid_index (read_ptr, 1);
											}
											if (last_trial && output_color_type == 3)
											{
												png_set_check_for_invalid_index (write_ptr, 1);
											}
											if (last_trial == 1)
											{
												png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) NULL, 0);
												if (save_apng_chunks == 1)
												{
													/* To do: Why use write_ptr not read_ptr here? */
													png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "acTL", 1);
													png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "fcTL", 1);
													png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "fdAT", 1);
												}
												if (idat.found_any_chunk == 1)
													png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "dSIG", 1);
												if (idat.all_chunks_are_safe)
												{
													png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) NULL, 0);
													if (save_apng_chunks == 0)
													{
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "acTL", 1);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "fcTL", 1);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "fdAT", 1);
													}
												}
												else
												{
													png_byte chunk_name[5];
													chunk_name[4] = '\0';
													/* To do: Why use write_ptr not read_ptr here? */
													if (!Param2.getIntValue())
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_bytep) NULL, 0);
													else
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_NEVER, (png_bytep) NULL, 0);

													if (!(Param2.getIntValue() & PNG_REMOVE_CHRM))
													{
														pngcrush_save_uint_32(chunk_name, PNG_UINT_cHRM);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
													}
													if (!(Param2.getIntValue() & PNG_REMOVE_HIST))
													{
														pngcrush_save_uint_32(chunk_name, PNG_UINT_hIST);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
													}
													if (!(Param2.getIntValue() & PNG_REMOVE_ICCP))
													{
														pngcrush_save_uint_32(chunk_name, PNG_UINT_iCCP);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
													}
													if (!(Param2.getIntValue() & PNG_REMOVE_ITXT))
													{
														pngcrush_save_uint_32(chunk_name, PNG_UINT_iTXt);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
													}
													if (!(Param2.getIntValue() & PNG_REMOVE_SCAL))
													{
														pngcrush_save_uint_32(chunk_name, PNG_UINT_sCAL);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
													}
													if (!(Param2.getIntValue() & PNG_REMOVE_PCAL))
													{
														pngcrush_save_uint_32(chunk_name, PNG_UINT_pCAL);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
													}
													if (!(Param2.getIntValue() & PNG_REMOVE_SPLT))
													{
														pngcrush_save_uint_32(chunk_name, PNG_UINT_sPLT);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
													}
													if (!(Param2.getIntValue() & PNG_REMOVE_STER))
													{
														pngcrush_save_uint_32(chunk_name, PNG_UINT_sTER);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
													}
													if (!(Param2.getIntValue() & PNG_REMOVE_TIME))
													{
														pngcrush_save_uint_32(chunk_name, PNG_UINT_tIME);
														png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
													}
												}
												if (idat.salvage && idat.found_CgBI)
												{
													/* Skip the CgBI chunk */
													png_skip_chunk(read_ptr);
													/* iCCP and zTXt are probably unreadable
													 * because of the nonstandard deflate */
													png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_NEVER, (png_bytep)"iCCP", 1);
													png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_NEVER, (png_bytep)"zTXt", 1);
												}
											}
											png_read_info(read_ptr, read_info_ptr);
											//----------------[ICCP]
											//----------------[SBIT]
											//----------------[BKGD]
											if (trial != 0)
											{
												if (pixel.make_opaque == 1)
												{
													if (output_color_type == 4)
														output_color_type = 0;
													if (output_color_type == 6)
														output_color_type = 2;
												}
												if (pixel.make_gray == 1)
												{
													/* Note: Take care that iCCP, sBIT, and bKGD data are not
													 * lost or become invalid when reducing images from
													 * truecolor to grayscale or when reducing the bit depth.
													 * (To do: test this; it's probably OK)
													 */
													/* To do: check bKGD color */
													if (output_color_type == 6)
														output_color_type = 4;
													if (output_color_type == 2)
														output_color_type = 0;
												}
												if (pixel.make_opaque != 1 && pixel.blacken == 2)
												{
													png_set_read_user_transform_fn(read_ptr, pngcrush_transform_pixels_fn);
												}
											}

											/* Start of chunk-copying/removal code, in order:
											 *  - IHDR
											 *  - bKGD
											 *  - cHRM
											 *  - gAMA
											 *  - sRGB
											 *  - iCCP
											 *  - oFFs
											 *  - pCAL
											 *  - pHYs
											 *  - hIST
											 *  - tRNS
											 *  - PLTE
											 *  - sBIT
											 *  - sCAL
											 *  - sPLT
											 *  - sTER
											 *  - tEXt/zTXt/iTXt
											 *  - tIME
											 *  - unknown chunks
											 */
											int compression_method, filter_method;
											png_uint_32 width, height;
											int bit_depth, color_type;
											int interlace_method = 0;
											
											if (png_get_IHDR(read_ptr, read_info_ptr, &width, &height,
																			 &bit_depth, &color_type, &interlace_method,
																			 &compression_method, &filter_method))
											{
												int need_expand = 0;
												idat.input_color_type = color_type;
												int input_bit_depth = bit_depth;
												
												if (output_color_type > 7)
												{
													output_color_type = idat.input_color_type;
												}

												output_bit_depth = input_bit_depth;
												
												if ((output_color_type != 3 || output_bit_depth > 8)
														&& output_bit_depth >= 8
														&& output_bit_depth > input_bit_depth)
													need_expand = 1;
												
												if ((color_type == 2 ||
														 color_type == 6 ||
														 color_type == 3) &&
														(output_color_type == 0 ||
														 output_color_type == 4))
												{
													png_set_rgb_to_gray_fixed(read_ptr, 1, 21260, 71520);
													if (output_bit_depth < 8)
														output_bit_depth = 8;
													if (color_type == 3)
														need_expand = 1;
												}
												if (color_type != 3 && output_color_type == 3)
												{
													output_color_type = idat.input_color_type;
												}
												
												if ((color_type == 0 || color_type == 4) &&
														(output_color_type == 2
														 || output_color_type == 6))
												{
													png_set_gray_to_rgb(read_ptr);
												}
												
												if ((color_type == 4 || color_type == 6) &&
														(output_color_type != 4
														 && output_color_type != 6))
												{
													png_set_strip_alpha(read_ptr);
												}
												
												if ((output_color_type == 4
														 || output_color_type == 6) && (color_type != 4
																														&& color_type != 6))
												{
													png_set_filler(read_ptr, (png_uint_32) 65535L, PNG_FILLER_AFTER);
													need_expand = 1;
												}
												
												if (output_color_type != 0 && output_color_type != 3 &&
														output_bit_depth < 8)
													output_bit_depth = 8;
												
												if ((output_color_type == 2
														 || output_color_type == 6)
														&& color_type == 3)
												{
													need_expand = 1;
												}
												if (need_expand == 1)
													png_set_expand(read_ptr);

												if (input_bit_depth < 8)
												{
													png_set_packing(read_ptr);
												}
												
												if (output_color_type == 0 && output_bit_depth < 8)
												{
													png_color_8 true_bits;
													true_bits.gray = (png_byte) (output_bit_depth);
													png_set_shift(read_ptr, &true_bits);
												}

												if (trial > 0)
												{
													/* TO DO: have we got the right plte_len now? */
													if (pixel.plte_len > 0 && output_color_type == 3 &&
															force_output_bit_depth == 0)
													{
														if (pixel.plte_len <= 2)
															force_output_bit_depth = 1;
														else if (pixel.plte_len <= 4)
															force_output_bit_depth = 2;
														else if (pixel.plte_len <= 16)
															force_output_bit_depth = 4;
														else
															force_output_bit_depth = 8;
													}
													
													if (pixel.make_8_bit == 1)
													{
														output_bit_depth = 8;
														force_output_bit_depth = 8;
														png_set_strip_16(read_ptr);
													}
												}
												
												if (last_trial == 1)
												{
													if (save_apng_chunks == 1 || idat.found_acTL_chunk == 1)
													{
														if (idat.input_color_type != output_color_type)
														{
															save_apng_chunks = 2;
														}
														if (input_bit_depth != output_bit_depth)
														{
															save_apng_chunks = 2;
														}
														if (save_apng_chunks != 1 && idat.found_acTL_chunk == 1)
															idat.found_acTL_chunk = 2;
													}
												}
												
												png_set_IHDR(write_ptr, write_info_ptr, width,
																		 height, output_bit_depth,
																		 output_color_type, interlace_method,
																		 compression_method, filter_method);
												
											} /* IHDR */
											/* Handle ancillary chunks */
											if (last_trial == 1)
											{
												png_color_16p background;
												if (!have_bkgd && png_get_bKGD(read_ptr, read_info_ptr, &background))
												{
													if (!(Param2.getIntValue() & PNG_REMOVE_BKGD))
													{
														if ((idat.input_color_type == 2 ||
																 idat.input_color_type == 6) &&
																(output_color_type == 0 ||
																 output_color_type == 4))
															background->gray = background->green;
														
														png_set_bKGD(write_ptr, write_info_ptr,
																				 background);
													}
												}
												if (have_bkgd)
												{
													/* If we are reducing an RGB image to grayscale, but
													 * the background color isn't gray, the green channel
													 * is written.  That's not spec-compliant.  We should
													 * really check for a non-gray bKGD and refuse to do
													 * the reduction if one is present.
													 */
													png_color_16 backgd;
													png_color_16p backgrnd = &backgd;
													backgrnd->red = bkgd_red;
													backgrnd->green = bkgd_green;
													backgrnd->blue = bkgd_blue;
													backgrnd->gray = backgrnd->green;
													backgrnd->index = bkgd_index;
													png_set_bKGD(write_ptr, write_info_ptr,
																			 backgrnd);
												}
												

												
#if defined(PNG_READ_cHRM_SUPPORTED) && defined(PNG_WRITE_cHRM_SUPPORTED)
#ifdef PNG_FIXED_POINT_SUPPORTED
												{
													png_fixed_point white_x, white_y, red_x, red_y,
													green_x, green_y, blue_x, blue_y;
													
													if (idat.found_cHRM && png_get_cHRM_fixed
															(read_ptr, read_info_ptr, &white_x, &white_y,
															 &red_x, &red_y, &green_x, &green_y, &blue_x,
															 &blue_y))
													{
														if (!(Param2.getIntValue() & PNG_REMOVE_CHRM))
														{
															png_set_cHRM_fixed(write_ptr,
																								 write_info_ptr, white_x,
																								 white_y, red_x, red_y,
																								 green_x, green_y,
																								 blue_x, blue_y);
														}
													}
												}
#else
												{
													double white_x, white_y, red_x, red_y, green_x,
													green_y, blue_x, blue_y;
													
													if (idat.found_cHRM && png_get_cHRM
															(read_ptr, read_info_ptr, &white_x, &white_y,
															 &red_x, &red_y, &green_x, &green_y, &blue_x,
															 &blue_y)) {
																if (!(Param2.getIntValue() & PNG_REMOVE_CHRM))
																{
																	png_set_cHRM(write_ptr, write_info_ptr,
																							 white_x, white_y, red_x,
																							 red_y, green_x, green_y,
																							 blue_x, blue_y);
																}
															}
												}
#endif /* PNG_FIXED_POINT_SUPPORTED */
#endif /* PNG_READ_cHRM_SUPPORTED && PNG_WRITE_cHRM_SUPPORTED */
												
#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_WRITE_gAMA_SUPPORTED)
												{
													if (force_specified_gamma)
													{
#ifdef PNG_FIXED_POINT_SUPPORTED
														png_set_gAMA_fixed(write_ptr, write_info_ptr,
																							 (png_fixed_point)
																							 force_specified_gamma);
														file_gamma =
														(png_fixed_point) force_specified_gamma;
#else
														png_set_gAMA(write_ptr, write_info_ptr,
																				 force_specified_gamma);
														file_gamma = force_specified_gamma;
#endif
													}
#ifdef PNG_FIXED_POINT_SUPPORTED
													else if (idat.found_gAMA && png_get_gAMA_fixed
																	 (read_ptr, read_info_ptr, &file_gamma))
#else
														else if (idat.found_gAMA && idat.png_get_gAMA
																		 (read_ptr, read_info_ptr, &file_gamma))
#endif
														{
															if (!(Param2.getIntValue() & PNG_REMOVE_GAMA))
															{
																if (idat.image_specified_gamma)
																	file_gamma = idat.image_specified_gamma;
																if (last_trial)
#ifdef PNG_FIXED_POINT_SUPPORTED
																if (double_gamma)
																	file_gamma += file_gamma;
																png_set_gAMA_fixed(write_ptr, write_info_ptr,
																									 file_gamma);
#else
																if (double_gamma)
																	file_gamma += file_gamma;
																png_set_gAMA(write_ptr, write_info_ptr,
																						 file_gamma);
#endif
															}
														}
														else if (specified_gamma)
														{
#ifdef PNG_FIXED_POINT_SUPPORTED
															png_set_gAMA_fixed(write_ptr, write_info_ptr,
																								 specified_gamma);
															file_gamma = (png_fixed_point) specified_gamma;
#else
															png_set_gAMA(write_ptr, write_info_ptr,
																					 specified_gamma);
															file_gamma = specified_gamma;
#endif
														}
												}
#endif /* PNG_READ_gAMA_SUPPORTED && PNG_WRITE_gAMA_SUPPORTED */
												
#if defined(PNG_READ_sRGB_SUPPORTED) && defined(PNG_WRITE_sRGB_SUPPORTED)
												{
													int file_intent;
													
													if (png_get_sRGB
															(read_ptr, read_info_ptr, &file_intent))
													{
														if (!(Param2.getIntValue() & PNG_REMOVE_SRGB))
														{
															png_set_sRGB(write_ptr, write_info_ptr,
																					 file_intent);
															idat.intent = file_intent;
														}
													}
													else if (idat.found_sRGB)
													{
#ifdef PNG_gAMA_SUPPORTED
#  ifdef PNG_FIXED_POINT_SUPPORTED
														if (file_gamma >= 45000L && file_gamma <= 46000L)
#  else
															if (file_gamma >= 0.45000 && file_gamma <= 0.46000)
#  endif
															{
																png_set_sRGB(write_ptr, write_info_ptr, idat.intent);
															}
#endif /* PNG_gAMA_SUPPORTED */
													}
												}
#endif /* PNG_READ_sRGB_SUPPORTED && PNG_WRITE_sRGB_SUPPORTED */
		
#if defined(PNG_READ_iCCP_SUPPORTED) && defined(PNG_WRITE_iCCP_SUPPORTED)
												if (idat.intent < 0) {  /* ignore iCCP if sRGB is being written */
													png_charp name;
#if PNGCRUSH_LIBPNG_VER < 10500
													png_charp profile;
#else
													png_bytep profile;
#endif
													png_uint_32 proflen;
													int compression_method;
													
													if (idat.found_iCCP && png_get_iCCP((png_const_structrp)read_ptr,
																															(png_inforp)read_info_ptr,
																															(png_charpp)&name,
																															(int *)&compression_method,
																															(png_bytepp)&profile,
																															(png_uint_32 *)&proflen))
													{

														if (!(Param2.getIntValue() & PNG_REMOVE_ICCP))
															png_set_iCCP((png_const_structrp)write_ptr,
																					 (png_inforp)write_info_ptr,
																					 (png_const_charp)name,
																					 (int)compression_method,
																					 (png_const_bytep)profile,
																					 (png_uint_32)proflen);
													}
#ifdef PNG_iCCP_SUPPORTED
													else if (iccp_length)
													{
														png_set_iCCP((png_const_structrp)write_ptr,
																				 (png_inforp)write_info_ptr,
																				 (png_const_charp)iccp_name,
																				 (int)0,
																				 (png_const_bytep) iccp_text,
																				 (png_uint_32)iccp_length);
													}
#endif /* PNG_iCCP_SUPPORTED */
													
												}
#endif /* PNG_READ_iCCP_SUPPORTED && PNG_WRITE_iCCP_SUPPORTED */
												
#if defined(PNG_READ_oFFs_SUPPORTED) && defined(PNG_WRITE_oFFs_SUPPORTED)
												{
													png_int_32 offset_x, offset_y;
													int unit_type;
													
													if (png_get_oFFs
															(read_ptr, read_info_ptr, &offset_x, &offset_y,
															 &unit_type)) {
																if (!(offset_x == 0 && offset_y == 0))
																{
																	if (!(Param2.getIntValue() & PNG_REMOVE_OFFS))
																		png_set_oFFs(write_ptr, write_info_ptr,
																								 offset_x, offset_y,
																								 unit_type);
																}
															}
												}
#endif /* PNG_READ_oFFs_SUPPORTED && PNG_WRITE_oFFs_SUPPORTED */
												
#if defined(PNG_READ_pCAL_SUPPORTED) && defined(PNG_WRITE_pCAL_SUPPORTED)
												{
													png_charp purpose, units;
													png_charpp params;
													png_int_32 X0, X1;
													int type, nparams;
													
													if (png_get_pCAL
															(read_ptr, read_info_ptr, &purpose, &X0, &X1,
															 &type, &nparams, &units, &params))
													{
														if (!(Param2.getIntValue() & PNG_REMOVE_PCAL))
															png_set_pCAL(write_ptr, write_info_ptr,
																					 purpose, X0, X1, type, nparams,
																					 units, params);
													}
												}
#endif /* pCAL_SUPPORTED */
												
#if defined(PNG_READ_pHYs_SUPPORTED) && defined(PNG_WRITE_pHYs_SUPPORTED)
												{
													png_uint_32 res_x, res_y;
													int unit_type;
													
													if (resolution == 0)
													{
														if (png_get_pHYs
																(read_ptr, read_info_ptr, &res_x, &res_y,
																 &unit_type))
														{
															if (!(res_x == 0 && res_y == 0))
															{
																if (!(Param2.getIntValue() & PNG_REMOVE_PHYS))
																	png_set_pHYs(write_ptr, write_info_ptr,
																							 res_x, res_y, unit_type);
															}
														}
													} else {
														unit_type = 1;
														res_x = res_y =
														(png_uint_32) ((resolution / .0254 + 0.5));
														png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);
													}
												}
#endif
												
#if defined(PNG_READ_hIST_SUPPORTED) && defined(PNG_WRITE_hIST_SUPPORTED)
												{
													png_uint_16p hist;
													
													if (png_get_hIST(read_ptr, read_info_ptr, &hist))
													{
														if (!(Param2.getIntValue() & PNG_REMOVE_HIST))
															png_set_hIST(write_ptr, write_info_ptr, hist);
													}
												}
#endif /* hIST_SUPPORTED */
												
#if defined(PNG_READ_tRNS_SUPPORTED) && defined(PNG_WRITE_tRNS_SUPPORTED)
												{
													if (png_get_tRNS
															(read_ptr, read_info_ptr, &trans, &num_trans,
															 &trans_values))
													{
														if (!(Param2.getIntValue() & PNG_REMOVE_TRNS))
														{
															int last_nonmax = -1;
															trns_red = trans_values->red;
															trns_green = trans_values->green;
															trns_blue = trans_values->blue;
															trns_gray = trans_values->gray;
															if (output_color_type == 3)
															{
																for (ia = 0; ia < num_trans; ia++)
																	trns_array[ia] = trans[ia];
																for (; ia < 256; ia++)
																	trns_array[ia] = 255;
																for (ia = 0; ia < 256; ia++)
																{
																	if (trns_array[ia] != 255)
																		last_nonmax = ia;
																}
																num_trans = last_nonmax + 1;
															}
															else
															{
																/* color type is 0 or 2 */
																if (input_bit_depth == 16 &&
																		output_bit_depth == 8)
																{
																	/* zero out the high byte */
																	trans_values->red &= 0x00ff;
																	trans_values->green &= 0x00ff;
																	trans_values->blue &= 0x00ff;
																	trans_values->gray &= 0x00ff;
																}
																
															}
															if (output_color_type < 3 || num_trans)
																png_set_tRNS(write_ptr, write_info_ptr, trans, num_trans, trans_values);
														}
													}
													else if (have_trns == 1)
													{
														/* will not overwrite existing trns data */
														png_color_16 trans_data;
														png_byte index_data = (png_byte) trns_index;
														num_trans = index_data + 1;
														if (output_color_type == 3)
														{
															trans_values = NULL;
															for (ia = 0; ia < num_trans; ia++)
																trns_array[ia] = trans_in[ia];
															for (; ia < 256; ia++)
																trns_array[ia] = 255;
														} else {
															for (ia = 0; ia < 256; ia++)
																trns_array[ia] = 255;
															trns_array[index_data] = 0;
															
															trans_data.index = index_data;
															trans_data.red = trns_red;
															trans_data.green = trns_green;
															trans_data.blue = trns_blue;
															trans_data.gray = trns_gray;
															trans_values = &trans_data;
														}
														png_set_tRNS(write_ptr, write_info_ptr, trns_array, num_trans, trans_values);
													}
													else
													{
														for (ia = 0; ia < 256; ia++)
															trns_array[ia] = 255;
													}
													if (last_trial)
													{
														int last = -1;
														for (ia = 0; ia < num_palette; ia++)
															if (trns_array[ia] != 255)
																last = ia;
													}
												}
#endif /* PNG_READ_tRNS_SUPPORTED && PNG_WRITE_tRNS_SUPPORTED */
											}  /* End of ancillary chunk handling */
											if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))
											{
												if (pixel.plte_len > 0)
													num_palette = pixel.plte_len;

												if (output_color_type == 3)
													png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
												else if (!(Param2.getIntValue() & PNG_REMOVE_PLTE))
													png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
												
												if (last_trial)
												{
													png_colorp p = palette;
													for (i = 0; i < num_palette; i++)
													{
														p++;
													}
												}
											}
											/* Handle ancillary chunks */
											if (last_trial == 1)
											{
#if defined(PNG_READ_sBIT_SUPPORTED) && defined(PNG_WRITE_sBIT_SUPPORTED)
												{
													png_color_8p sig_bit;
													
													/* If we are reducing a truecolor PNG to grayscale, and the
													 * RGB sBIT values aren't identical, we'll lose sBIT info.
													 */
													if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))
													{
														if (!(Param2.getIntValue() & PNG_REMOVE_SBIT))
														{
															if ((idat.input_color_type == 0
																	 || idat.input_color_type == 4)
																	&& (output_color_type == 2
																			|| output_color_type == 6
																			|| output_color_type == 3))
																sig_bit->red = sig_bit->green =
																sig_bit->blue = sig_bit->gray;
															if ((idat.input_color_type == 2
																	 || idat.input_color_type == 6
																	 || output_color_type == 3)
																	&& (output_color_type == 0
																			|| output_color_type == 4))
																sig_bit->gray = sig_bit->green;
															
															if ((idat.input_color_type == 0
																	 || idat.input_color_type == 2)
																	&& (output_color_type == 4
																			|| output_color_type == 6))
																sig_bit->alpha = 1;

																png_set_sBIT(write_ptr, write_info_ptr,
																						 sig_bit);
														}
													}
												}
#endif /* PNG_READ_sBIT_SUPPORTED)&& PNG_WRITE_sBIT_SUPPORTED */
												
#ifdef PNG_sCAL_SUPPORTED
#  ifdef PNG_FLOATING_POINT_SUPPORTED
												{
													int unit;
													double scal_width, scal_height;
													
													if (png_get_sCAL
															(read_ptr, read_info_ptr, &unit, &scal_width,
															 &scal_height))
													{
														png_set_sCAL(write_ptr, write_info_ptr, unit,
																				 scal_width, scal_height);
													}
												}
#  else
#    ifdef PNG_FIXED_POINT_SUPPORTED
												{
													int unit;
													png_charp scal_width, scal_height;
													
													if (png_get_sCAL_s
															(read_ptr, read_info_ptr, &unit, &scal_width,
															 &scal_height))
													{
														if (!(Param2.getIntValue() & PNG_REMOVE_SCAL))
															png_set_sCAL_s(write_ptr, write_info_ptr, unit,
																						 scal_width, scal_height);
													}
												}
#    endif
#  endif /* PNG_FLOATING_POINT_SUPPORTED */
#endif /* PNG_sCAL_SUPPORTED */
												
#ifdef PNG_sPLT_SUPPORTED
												{
													png_sPLT_tp entries;
													int num_entries;
													
													num_entries =
													(int) png_get_sPLT(read_ptr, read_info_ptr,
																						 &entries);
													if (num_entries)
													{
														if (!(Param2.getIntValue() & PNG_REMOVE_SPLT))
															png_set_sPLT(write_ptr, write_info_ptr,
																					 entries, num_entries);
													}
												}
#endif
												
#ifdef PNG_TEXT_SUPPORTED
												{
													png_textp text_ptr;
													int num_text = 0;
													
													if (png_get_text
															(read_ptr, read_info_ptr, &text_ptr, &num_text) > 0
															|| text_inputs)
													{
														int ntext;
														if (num_text > 0)
														{
															if (!(Param2.getIntValue() & PNG_REMOVE_TEXT))
															{
																int num_to_write = num_text;
																for (ntext = 0; ntext < num_text; ntext++)
																{
																	if (text_ptr[ntext].compression ==
																			PNG_TEXT_COMPRESSION_NONE) {
																		if (Param2.getIntValue() & PNG_REMOVE_TEXT)
																		{
																			text_ptr[ntext].key[0] = '\0';
																			num_to_write--;
																		}
																	}
																	if (text_ptr[ntext].compression ==
																			PNG_TEXT_COMPRESSION_zTXt)
																	{
																		if (Param2.getIntValue() & PNG_REMOVE_ZTXT)
																		{
																			text_ptr[ntext].key[0] = '\0';
																			num_to_write--;
																		}
																	}
#ifdef PNG_iTXt_SUPPORTED
																	if (text_ptr[ntext].compression ==
																			PNG_ITXT_COMPRESSION_NONE
																			|| text_ptr[ntext].compression ==
																			PNG_ITXT_COMPRESSION_zTXt)
																	{
																		if (Param2.getIntValue() & PNG_REMOVE_ITXT)
																		{
																			text_ptr[ntext].key[0] = '\0';
																			num_to_write--;
																		}
																	}
#endif
																}
																if (num_to_write > 0)
																	png_set_text(write_ptr, write_info_ptr,
																							 text_ptr, num_text);
															}
														}
														for (ntext = 0; ntext < text_inputs; ntext++)
														{
															if (text_where[ntext] == 1)
															{
																png_textp added_text;
																added_text = (png_textp) png_malloc(write_ptr, (png_uint_32) sizeof(png_text));
																added_text[0].key = &text_keyword[ntext * 80];
#ifdef PNG_iTXt_SUPPORTED
																added_text[0].lang = &text_lang[ntext * 80];
																added_text[0].lang_key =
																&text_lang_key[ntext * 80];
#endif
																added_text[0].text =
																&text_text[ntext * STR_BUF_SIZE];
																added_text[0].compression =
																text_compression[ntext];
																png_set_text(write_ptr, write_info_ptr, added_text, 1);
																png_free(write_ptr, added_text);
																added_text = (png_textp) NULL;
															}
														}
													}
												}
#endif /* defined(PNG_TEXT_SUPPORTED) */
												
#if defined(PNG_READ_tIME_SUPPORTED) && defined(PNG_WRITE_tIME_SUPPORTED)
												{
													png_timep mod_time;
													if (png_get_tIME(read_ptr, read_info_ptr, &mod_time))
													{
														if (!(Param2.getIntValue() & PNG_REMOVE_TIME))
															png_set_tIME(write_ptr, write_info_ptr, mod_time);
													}
												}
#endif
#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
												/* This section handles pCAL and tIME (at least, in default
												 * build), gIFx/gIFg/gIFt, private Fireworks chunks, etc. */
												{
													png_unknown_chunkp unknowns;   /* allocated by libpng */
													int num_unknowns;
													num_unknowns = (int)png_get_unknown_chunks(read_ptr, read_info_ptr, &unknowns);
													if (ster_mode >= 0)
													{
														/* Add sTER chunk */
														png_unknown_chunkp ster;
														ster = (png_unknown_chunk*)png_malloc(read_ptr, (png_uint_32) sizeof(png_unknown_chunk));
														png_memcpy((char *)ster[0].name, "sTER",5);
														ster[0].size = 1;
														ster[0].data = (png_byte*)png_malloc(read_ptr, 1);
														ster[0].data[0] = (png_byte)ster_mode;
														png_set_unknown_chunks(read_ptr, read_info_ptr, ster, 1);
														png_free(read_ptr,ster[0].data);
														png_free(read_ptr,ster);
														num_unknowns++;
													}

													if (ster_mode >= 0)
														png_set_unknown_chunk_location(read_ptr, read_info_ptr, num_unknowns - 1, (int)PNG_HAVE_IHDR);
													
												}
#endif /* PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED */
											}  /* End of ancillary chunk handling */
											/*
											 * Would be useful to have a libpng fix, that either exports
											 * png_read_transform_info() or provides a generic API that
											 * can set any png_ptr->flag, or, simpler, provides an API
											 * to set the PNG_FLAG_ROW_INIT flag.
											 *
											 * Starting in libpng-1.5.6beta06, png_read_update_info()
											 * does not check the PNG_FLAG_ROW_INIT flag and does not
											 * initialize the row or issue a warning.
											 *
											 */
#ifdef PNGCRUSH_H
											png_read_transform_info(read_ptr, read_info_ptr);
#else
											/* Some pngcrush capabilities are lacking when the system
											 * libpng is used instead of the one bundled with pngcrush
											 *
											 * To do: list those capabilities here
											 */
											
											/* pngcrush fails to read interlaced PNGs properly
											 * when png_read_update_info() is called here.
											 */
											
											/* png_read_update_info(read_ptr, read_info_ptr); */
											
											/* Workaround is to multiply rowbytes by 8/bit_depth
											 * to allow for unpacking, wherever we allocate a
											 * row buffer.  This results in too large a value for
											 * rowbytes under some conditions, e.g., when increasing
											 * a sub-8-bit file to RGBA, but this is rare and harmless.
											 */
#endif
											if (filter_type == 0)
												png_set_filter(write_ptr, 0, PNG_FILTER_NONE);
											else if (filter_type == 1)
												png_set_filter(write_ptr, 0, PNG_FILTER_SUB);
											else if (filter_type == 2)
												png_set_filter(write_ptr, 0, PNG_FILTER_UP);
											else if (filter_type == 3)
												png_set_filter(write_ptr, 0, PNG_FILTER_AVG);
											else if (filter_type == 4)
												png_set_filter(write_ptr, 0, PNG_FILTER_PAETH);
											else if (filter_type == 5)
											{
												if (speed)
												{
													png_set_filter(write_ptr, 0, PNG_FILTER_NONE |
																				 PNG_FILTER_SUB | PNG_FILTER_UP);
												}
												else
												{
													png_set_filter(write_ptr, 0, PNG_ALL_FILTERS);
												}
											}
											else
												png_set_filter(write_ptr, 0, PNG_FILTER_NONE);
											
											{
//												png_uint_32 zbuf_size;
												png_uint_32 required_window;
												int channels = 0;
												png_set_compression_strategy(write_ptr, z_strategy);
												png_set_compression_mem_level(write_ptr, compression_mem_level);
												if (output_color_type == 0)
													channels = 1;
												if (output_color_type == 2)
													channels = 3;
												if (output_color_type == 3)
													channels = 1;
												if (output_color_type == 4)
													channels = 2;
												if (output_color_type == 6)
													channels = 4;
												/* This method was copied from libpng to find maximum
												 * data size.  Only return sizes up to the maximum of
												 * a png_uint_32, by limiting the width and height used
												 * to 15 bits.
												 */
												png_uint_32 rowbytes;
												png_uint_32 h = height;
												/* FIX THIS, does not work with libpng-1.7.0
												 * because info_ptr->bit_depth has not been
												 * updated yet.
												 */
												rowbytes = png_get_rowbytes(read_ptr, read_info_ptr);
												if (rowbytes < 16384 && h < 16384)
												{
													if (rowbytes * h < 16384)
													{
														if (interlace_method)
														{
															/* Interlacing makes the uncompressed data
															 * larger because of the replication of both
															 * the filter byte and the padding to a byte
															 * boundary.
															 */
															png_uint_32 w = width;
															unsigned int pd = channels * output_bit_depth;
															png_alloc_size_t cb_base;
															int interlace_pass;
															for (cb_base=0, interlace_pass=0; interlace_pass<=6; ++interlace_pass)
															{
																png_uint_32 pw = PNG_PASS_COLS(w, interlace_pass);
																if (pw > 0)
																	cb_base += (PNGCRUSH_ROWBYTES(pd, pw)+1) * PNG_PASS_ROWS(h, interlace_pass);
															}
															max_bytes = cb_base;
														}
														else
															//!interlace_method
															max_bytes = (rowbytes+1) * h;
													}
													else
														//!(rowbytes * h < 16384)
														max_bytes = 0x3fffffffU;
												}
												else
													//!(rowbytes < 16384 && h < 16384)
													max_bytes = 0x3fffffffU;
												
												required_window = (png_uint_32) (max_bytes + 262);
												//bad calculation, ends up in memory error
												/* reinitialize zbuf - compression buffer */
												/*
												zbuf_size = png_get_compression_buffer_size(write_ptr);
												if (zbuf_size != max_idat_size)
												{
													png_uint_32 max_possible_size = required_window;
													png_set_compression_buffer_size(write_ptr, max_possible_size);
												}
												*/
												if (required_window <= 512)
													compression_window = 9;
												else if (required_window <= 1024)
													compression_window = 10;
												else if (required_window <= 2048)
													compression_window = 11;
												else if (required_window <= 4096)
													compression_window = 12;
												else if (required_window <= 8192)
													compression_window = 13;
												else if (required_window <= 16384)
													compression_window = 14;
												else
													compression_window = 15;
												if (compression_window > default_compression_window || force_compression_window)
													compression_window = default_compression_window;
												
												png_set_compression_window_bits(write_ptr, compression_window);
											}
											png_set_compression_level(write_ptr, zlib_level);
											png_write_info(write_ptr, write_info_ptr);
											if (output_bit_depth < 8)
											{
												if (output_color_type == 0)
												{
													png_color_8 true_bits;
													true_bits.gray = (png_byte) (output_bit_depth);
													png_set_shift(write_ptr, &true_bits);
												}
												png_set_packing(write_ptr);
											}
											png_uint_32 rowbytes_s;
											png_uint_32 rowbytes;
											rowbytes = png_get_rowbytes(read_ptr, read_info_ptr);
											rowbytes_s = (png_size_t) rowbytes;
											if (rowbytes == (png_uint_32) rowbytes_s)
											{
												row_buf = (png_bytep)png_malloc(read_ptr, rowbytes + 64);
											}
											else
											{
												row_buf = NULL;
											}
											num_pass = png_set_interlace_handling(read_ptr);
											png_set_interlace_handling(write_ptr);
											t_stop = (TIME_T) clock();
											t_misc += (t_stop - t_start);
											if (t_stop < t_start)
											{
												t_misc += PNG_UINT_31_MAX;
												if (t_stop < 0)
													t_misc += PNG_UINT_31_MAX;
											}
											t_start = t_stop;
											for (pass = 0; pass < num_pass; pass++)
											{
													for (y = 0; y < height; y++)
													{
														png_read_row(read_ptr, row_buf, (png_bytep) NULL);
														t_stop = (TIME_T) clock();
														t_decode += (t_stop - t_start);
														if (t_stop < t_start)
														{
															t_decode += PNG_UINT_31_MAX;
															if (t_stop < 0)
																t_decode += PNG_UINT_31_MAX;
														}
														t_start = t_stop;
														/* To do: zero the padding bits */
														png_write_row(write_ptr, row_buf);
														pngcrush_write_byte_count = pngOut.len;
														t_stop = (TIME_T) clock();
														t_encode += (t_stop - t_start);
														if (t_stop < t_start)
														{
															t_encode += PNG_UINT_31_MAX;
															if (t_stop < 0)
																t_encode += PNG_UINT_31_MAX;
														}
														t_start = t_stop;
														
														/* Bail if byte count exceeds best so far */
														if (bail == 0 && trial != MAX_METHODS &&
																pngcrush_write_byte_count >
																pngcrush_best_byte_count)
														{
															png_write_flush(write_ptr);
															break;
														}
													}
												if (bail == 0 && trial != MAX_METHODS &&
														pngcrush_write_byte_count >
														pngcrush_best_byte_count)
													break;
											}
											if (color_type == 3)
											{
												if (trial == 0 && pixel.reduce_palette == 1)
												{
													int palette_length = pixel.plte_len;
													{
														png_color_16p bkgd;
														if (png_get_bKGD(read_ptr, read_info_ptr, &bkgd))
														{
															bkgd_index = bkgd->index;
															if (bkgd_index > palette_length)
															{
																bkgd_index = palette_length;
																have_bkgd = 1;
															}
															if (bkgd->index >= palette_length)
																palette_length = (int) bkgd_index+1;
														}
													}
													pixel.plte_len = palette_length;
													if (num_trans > pixel.plte_len)
													{
														num_trans = pixel.plte_len;
														png_set_tRNS(write_ptr, write_info_ptr, trns_array, num_trans, trans_values);
													}
												}
											}
											t_stop = (TIME_T) clock();
											t_decode += (t_stop - t_start);
											if (t_stop < t_start)
											{
												t_decode += PNG_UINT_31_MAX;
												if (t_stop < 0)
													t_decode += PNG_UINT_31_MAX;
											}
											t_start = t_stop;
											png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);
											png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);
											if (!(bail == 0 && trial != MAX_METHODS && pngOut.len > pngcrush_best_byte_count))
											{
												png_read_end(read_ptr, end_info_ptr);
												/* Handle ancillary chunks */
												if (last_trial == 1)
												{
													png_textp text_ptr;
													int num_text = 0;
													if (png_get_text (read_ptr, end_info_ptr, &text_ptr, &num_text) > 0 || text_inputs)
													{
														int ntext;
														if (last_trial)
														{
															if (num_text > 0)
															{
																if (!(Param2.getIntValue() & PNG_REMOVE_TEXT))
																{
																	int num_to_write = num_text;
																	for (ntext = 0; ntext < num_text; ntext++)
																	{
																		if (text_ptr[ntext].compression == PNG_TEXT_COMPRESSION_NONE)
																		{
																			if (Param2.getIntValue() & PNG_REMOVE_TIME)
																			{
																				text_ptr[ntext].key[0] = '\0';
																				num_to_write--;
																			}
																		}
																		if (text_ptr[ntext].compression == PNG_TEXT_COMPRESSION_zTXt)
																		{
																			if (!(Param2.getIntValue() & PNG_REMOVE_ZTXT))
																			{
																				text_ptr[ntext].key[0] = '\0';
																				num_to_write--;
																			}
																		}
																		if (text_ptr[ntext].compression == PNG_ITXT_COMPRESSION_NONE || text_ptr[ntext].compression == PNG_ITXT_COMPRESSION_zTXt)
																		{
																			if (Param2.getIntValue() & PNG_REMOVE_ITXT)
																			{
																				text_ptr[ntext].key[0] = '\0';
																				num_to_write--;
																			}
																		}
																	}
																	if (num_to_write > 0)
																	{
																		png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);
																	}
																}
															}
															for (ntext = 0; ntext < text_inputs; ntext++)
															{
																if (text_where[ntext] == 2)
																{
																	png_textp added_text;
																	added_text = (png_textp)png_malloc(write_ptr, (png_uint_32)sizeof(png_text));
																	added_text[0].key = &text_keyword[ntext * 80];
																	added_text[0].lang = &text_lang[ntext * 80];
																	added_text[0].lang_key = &text_lang_key[ntext * 80];
																	added_text[0].text = &text_text[ntext * STR_BUF_SIZE];
																	added_text[0].compression = text_compression[ntext];
																	png_set_text(write_ptr, write_end_info_ptr, added_text, 1);
																	png_free(write_ptr, added_text);
																	added_text = (png_textp) NULL;
																}
															}
														}
													}
												}
												//----------------[TIME]
												png_timep mod_time;
												if (png_get_tIME(read_ptr, end_info_ptr, &mod_time))
												{
													if (!(Param2.getIntValue() & PNG_REMOVE_TIME))
													{
														png_set_tIME(write_ptr, write_end_info_ptr, mod_time);
													}
												}
												//----------------[UNKN]
												png_unknown_chunkp unknowns;
												int num_unknowns = (int) png_get_unknown_chunks(read_ptr, end_info_ptr, &unknowns);
												if (num_unknowns)
												{
													png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns, num_unknowns);
													for (i = 0; i < num_unknowns; i++)
													{
														png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i, (int)unknowns[i].location);
													}
												}
											}
											png_write_end(write_ptr, write_end_info_ptr);
											png_free(read_ptr, row_buf);
											row_buf = (png_bytep) NULL;
											//record byte count for this trial round
											pngcrush_write_byte_count = pngOut.len;
											idat_length[trial] = pngcrush_write_byte_count;
											if (pngcrush_write_byte_count < pngcrush_best_byte_count)
											{
												pngcrush_best_byte_count = pngcrush_write_byte_count;
											}
											if (last_trial == 1)
											{
												//unless we have broken with the original image
												PA_Picture picture = PA_CreatePicture((void *)png.getBytesPtr(), png.getBytesLength());
												*(PA_Picture*) pResult = picture;
											}
											png_destroy_info_struct(write_ptr, &write_end_info_ptr);
											png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
										}
									}
								}
							}
						}
					}
				}
			}
		}
	}
}


