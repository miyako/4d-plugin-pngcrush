/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Pngcrush.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Pngcrush
 #	author : miyako
 #	2020/02/07
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Pngcrush.h"

#include <time.h>

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
			// --- Pngcrush
            
			case 1 :
				Pngcrush(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void pngcrush_write_png(png_structp png_ptr, png_bytep data, png_size_t length)
{
    PNGOutDataPtr pngOut = (PNGOutDataPtr)png_get_io_ptr(png_ptr);
    
    if(pngOut->last_trial)
    {
        pngOut->blob->addBytes((const uint8_t *)data, (uint32_t)length);
    }
    pngOut->len += length;
}

static void pngcrush_cexcept_error(png_structp png_ptr, png_const_charp error_msg)
{
    throw std::invalid_argument(error_msg);
}

void pngcrush_error(png_structp png_ptr, png_const_charp error_msg)
{
    throw std::invalid_argument(error_msg);
}

void pngcrush_warning(png_structp png_ptr, png_const_charp warning_msg)
{
    printf("%s", warning_msg);
}

void pngcrush_read_png(png_structp png_ptr, png_bytep data, png_size_t length)
{
    PNGDataPtr dataptr = (PNGDataPtr)png_get_io_ptr(png_ptr);
    png_uint_32 i;
    
    if (length <= dataptr->len)
    {
        for (i = 0; i < length; i++)
            data[i] = dataptr->p[i];
        
        dataptr->p += length;
        dataptr->len -= length;
    }
}

static void pngcrush_flush(png_structp png_ptr)
{

}

png_uint_32 PNGAPI pngcrush_get_uint_31(png_const_structrp png_ptr, png_const_bytep buf)
{
    png_uint_32 uval = png_get_uint_32(buf);
    
    if (uval > PNG_UINT_31_MAX)
        throw std::invalid_argument("PNG unsigned integer out of range");
    
    return (uval);
}

void pngcrush_examine_pixels_fn(png_structp png_ptr, png_row_infop row_info, png_bytep data)
{
    png_pixelp pixel = (png_pixelp)png_get_user_transform_ptr(png_ptr);
    
    if (pixel->blacken == 1 || pixel->make_gray == 1 || pixel->make_opaque == 1)
    {
        /* Check if there are any fully transparent pixels.  If one is found,
         * without the underlying color already black, set blacken==2. If the
         * PNG colortype does not support an alpha channel, set blacken==3.
         *
         * Check if there are any transparent pixels.  If one is found,
         * set make_opaque==2. If the PNG colortype does not support an alpha
         * channel, set make_opaque==3.
         *
         * Check if there are any non-gray pixels.  If one is found,
         * set make_gray == 2. If the PNG colortype is already gray, set
         * make_gray = 3.
         *
         * Check if any 16-bit pixels do not have identical high and low
         * bytes.  If one is found, set make_8_bit == 2. If the PNG bit_depth
         * is not 16-bits, set make_8_bit = 3.
         *
         * Find the maximum palette entry present in the IDAT chunks of
         * an indexed PNG.
         *
         */
        
        int i;
        
        if (row_info->color_type < 4)
        {
            pixel->blacken = 3;  /* It doesn't have an alpha channel */
            /* To do: check if tRNS chunk can be removed from color type 0 or 2 */
            pixel->make_opaque = 3;
        }
        
        if (row_info->color_type == 0 || row_info->color_type == 4)
            pixel->make_gray = 3; /* It's already gray! */
        
        if (row_info->color_type == 3)
            pixel->make_gray = 3; /* Don't change indexed PNG */
        
        if (row_info->bit_depth < 16)
            pixel->make_8_bit = 3;
        
        i = (int) row_info->rowbytes-1;
        
        if ((row_info->color_type == 2 || row_info->color_type == 6) &&
                pixel->make_gray == 1) /* RGB */
        {
            if (row_info->bit_depth == 8)
            {
                int incr=3;
                if (row_info->color_type == 6)
                {
                    incr=4;
                    i--;
                }
                for ( ; i > 0 ; )
                {
                    if (data[i] != data[i-1] || data[i] != data[i-2])
                    {
                        pixel->make_gray = 2;
                    }
                    
                    i-=incr;
                }
            }
            
            else /* bit depth == 16 */
            {
                int incr = 6;
                if (row_info->color_type == 6)
                {
                    incr = 8;
                    i-=2;
                }
                for ( ; i > 0 ; )
                {
                    if (data[i] != data[i-2] || data[i] != data[i-4] ||
                            data[i-1] != data[i-3] || data[i-1] != data[i-5])
                    {
                        pixel->make_gray = 2;
                    }
                    i-=incr;
                }
            }
        }
        
        else if (row_info->color_type == 4 && (pixel->blacken == 1 ||
                                                                                     pixel->make_opaque == 1)) /* GA */
        {
            i = (int) row_info->rowbytes-1;
            
            if (row_info->bit_depth == 8)
            {
                for ( ; i > 0 ; )
                {
                    if (pixel->blacken == 1 && data[i] == 0 &&  data[i-1] != 0)
                    {
                        pixel->blacken = 2;
                    }
                    
                    if (pixel->make_opaque == 1 && data[i] != 255)
                    {
                        pixel->make_opaque = 2;
                    }
                    i-=2;
                }
            }
            
            else /* bit depth == 16 */
            {
                for ( ; i > 0 ; )
                {
                    if (pixel->blacken == 1 && (data[i] == 0 && data[i-1] == 0) &&
                            (data[i-2] != 0 || data[i-3] != 0))
                    {
                        pixel->blacken = 2;
                    }
                    
                    if (pixel->make_opaque == 1 && (data[i] != 255 || data[i-1] != 255))
                    {
                        pixel->make_opaque = 2;
                    }
                    i-=4;
                }
            }
        }
        
        /* color_type == 6, RGBA */
        if (row_info->color_type == 6 && (pixel->blacken == 1 || pixel->make_gray == 1 ||
                                                                            pixel->make_opaque == 1))
        {
            i = (int) row_info->rowbytes-1;
            
            if (row_info->bit_depth == 8)
            {
                for ( ; i > 0 ; )
                {
                    if (pixel->blacken == 1 && data[i] == 0 &&
                            (data[i-1] != 0 || data[i-2] != 0 || data[i-3] != 0))
                    {
                        pixel->blacken = 2;
                    }
                    
                    if (pixel->make_gray == 1 &&
                            (data[i-1] != data[i-2] || data[i-1] != data[i-3]))
                    {
                        pixel->make_gray = 2;
                    }
                    
                    if (pixel->make_opaque == 1 && data[i] != 255)
                    {
                        pixel->make_opaque = 2;
                    }
                    
                    i-=4;
                }
            }
            
            else /* bit depth == 16 */
            {
                for ( ; i > 0 ; )
                {
                    if (pixel->blacken == 1 && (data[i] == 0 && data[i-1]== 0) &&
                            (data[i-2] != 0 || data[i-3] != 0 || data[i-4] != 0 ||
                             data[i-5] != 0 || data[i-6] != 0 || data[i-7] != 0))
                    {
                        pixel->blacken = 2;
                    }
                    
                    if (pixel->make_gray == 1 &&
                            (data[i-2] != data[i-4] || data[i-2] != data[i-6] ||
                             data[i-3] != data[i-5] || data[i-3] != data[i-7]))
                    {
                        pixel->make_gray = 2;
                    }
                    
                    if (pixel->make_opaque == 1 && (data[i] != 255 || data[i-1] != 255))
                    {
                        pixel->make_opaque = 2;
                    }
                    
                    i-=8;
                }
            }
        }
    }
    
    if (pixel->make_8_bit == 1)
    {
        int i;
        i = (int) row_info->rowbytes-1;
        
        if (row_info->color_type == 0)
        {
            for ( ; i > 0 ; )
            {
                if (data[i] != data[i-1])
                    pixel->make_8_bit = 2;
                i-=2;
            }
        }
        
        if (row_info->color_type == 2)
        {
            for ( ; i > 0 ; )
            {
                if (data[i] != data[i-1] || data[i-2] != data[i-3] ||
                        data[i-4] != data [i-5])
                    pixel->make_8_bit = 2;
                i-=6;
            }
        }
        
        if (row_info->color_type == 4)
        {
            for ( ; i > 0 ; )
            {
                if (data[i] != data[i-1] || data[i-2] != data[i-3])
                    pixel->make_8_bit = 2;
                i-=4;
            }
        }
        
        if (row_info->color_type == 6)
        {
            for ( ; i > 0 ; )
            {
                if (data[i] != data[i-1] || data[i-2] != data[i-3] ||
                        data[i-4] != data [i-5] || data[i-6] != data[i-7])
                    pixel->make_8_bit = 2;
                i-=8;
            }
        }
    }
    
    if (pixel->reduce_palette == 1 && row_info->color_type == 3)
    {
        int i;
        i = (int) row_info->rowbytes-1;
        
        for ( ; i > 0 ; i--)
        {
            if (data[i] >= pixel->plte_len)
                pixel->plte_len = data[i] + 1;
        }
    }
}

void PNGCBAPI pngcrush_default_read_data(png_structp png_ptr, png_bytep data, png_size_t length)
{
    PNGDataPtr dataptr = (PNGDataPtr)png_get_io_ptr(png_ptr);
    png_uint_32 i;
    
    if (length != 0)
    {
        for (i = 0; i < length; i++)
            data[i] = dataptr->p[i];
        
        dataptr->p += length;
        dataptr->len -= length;
    }
}

void PNGAPI pngcrush_calculate_crc(png_structp png_ptr, png_bytep ptr, png_size_t length, png_uint_32 *pngcrush_crc)
{
    *pngcrush_crc = crc32(*pngcrush_crc, ptr, (uInt)length);
}

void PNGAPI pngcrush_crc_read(png_structp png_ptr, png_bytep buf, png_size_t length, png_uint_32 *pngcrush_crc)
{
    pngcrush_default_read_data(png_ptr, buf, length);
    pngcrush_calculate_crc(png_ptr, buf, length, pngcrush_crc);
}

void PNGAPI pngcrush_reset_crc(png_structp png_ptr, png_uint_32 *pngcrush_crc)
{
    *pngcrush_crc = crc32(0, Z_NULL, 0);
}

int pngcrush_crc_error(png_structrp png_ptr)
{
    png_byte crc_bytes[4];
    png_uint_32 crc;
    int need_crc = 1;
    
    if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0)
    {
        if ((png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_MASK) ==
                (PNG_FLAG_CRC_ANCILLARY_USE | PNG_FLAG_CRC_ANCILLARY_NOWARN))
            need_crc = 0;
    }
    
    else /* critical */
    {
        if ((png_ptr->flags & PNG_FLAG_CRC_CRITICAL_IGNORE) != 0)
            need_crc = 0;
    }
    
#ifdef PNG_IO_STATE_SUPPORTED
    png_ptr->io_state = PNG_IO_READING | PNG_IO_CHUNK_CRC;
#endif
    
    /* The chunk CRC must be serialized in a single I/O call. */
    png_read_data(png_ptr, crc_bytes, 4);
    
    if (need_crc != 0)
    {
        crc = png_get_uint_32(crc_bytes);
        return ((int)(crc != png_ptr->crc));
    }
    
    else
        return (0);
}

int pngcrush_crc_finish(png_structrp png_ptr, png_uint_32 skip, png_uint_32 *pngcrush_crc)
{
    /* The size of the local buffer for inflate is a good guess as to a
     * reasonable size to use for buffering reads from the application.
     */
    while (skip > 0)
    {
        png_uint_32 len;
        png_byte tmpbuf[PNG_INFLATE_BUF_SIZE];
        
        len = (sizeof tmpbuf);
        if (len > skip)
            len = skip;
        skip -= len;
        
        pngcrush_crc_read(png_ptr, tmpbuf, len, pngcrush_crc);
    }
    
    if (pngcrush_crc_error(png_ptr) != 0)
    {
        if (PNG_CHUNK_ANCILLARY(png_ptr->chunk_name) != 0 ?
                (png_ptr->flags & PNG_FLAG_CRC_ANCILLARY_NOWARN) == 0 :
                (png_ptr->flags & PNG_FLAG_CRC_CRITICAL_USE) != 0)
        {
            //warning
        }
        
//        else
//            throw std::invalid_argument("CRC error");
        
        return (1);
    }
    
    return (0);
}

void pngcrush_transform_pixels_fn(png_structp png_ptr, png_row_infop row_info,
                                                                    png_bytep data)
{
    
    int i;
    png_pixelp pixel = (png_pixelp)png_get_user_transform_ptr(png_ptr);
    
    if (pixel->blacken == 2)
    {
        /* change the underlying color of any fully transparent pixels to black */
        i=(int) row_info->rowbytes-1;
        
        if (row_info->color_type == 4) /* GA */
        {
            if (row_info->bit_depth == 8)
            {
                for ( ; i > 0 ; )
                {
                    if (data[i] == 0 &&  data[i-1] != 0)
                    {
                        data[i-1]=0;
                    }
                    i-=2;
                }
            }
            
            else /* bit depth == 16 */
            {
                for ( ; i > 0 ; )
                {
                    if (data[i] == 0 && data[i-1] == 0)
                    {
                        data[i-2]=0;
                        data[i-3]=0;
                    }
                    i-=4;
                }
            }
        }
        
        else /* color_type == 6, RGBA */
        {
            if (row_info->bit_depth == 8)
            {
                for ( ; i > 0 ; )
                {
                    if (data[i] == 0)
                    {
                        data[i-1]=0;
                        data[i-2]=0;
                        data[i-3]=0;
                    }
                    i-=4;
                }
            }
            
            else /* bit depth == 16 */
            {
                for ( ; i > 0 ; )
                {
                    if (data[i] == 0 && data[i-1] == 0)
                    {
                        data[i-2]=0;
                        data[i-3]=0;
                        data[i-4]=0;
                        data[i-5]=0;
                        data[i-6]=0;
                        data[i-7]=0;
                    }
                    i-=8;
                }
            }
        }
    }
}

/* Grab an unsigned 32-bit integer from a buffer in big-endian format. */
png_uint_32 pngcrush_get_uint_32(png_bytep buf)
{
    png_uint_32 i = ((png_uint_32) (*buf & 0xff) << 24) +
    (*(buf + 1) << 16) + (*(buf + 2) <<  8) + (*(buf + 3)) ;
    
    return (i);
}

#pragma mark -

void png_skip_chunk(png_structp png_ptr)
{
    png_byte buff[4] = { 0, 0, 0, 0 };
    int ib;
    unsigned long length;
    
    /* read the length field */
    pngcrush_default_read_data(png_ptr, buff, 4);
    length = pngcrush_get_uint_31(png_ptr,buff);
    /* read the chunk name */
    pngcrush_default_read_data(png_ptr, buff, 4);
    
    /* skip the data and CRC */
    for (ib=0; ib<length+4; ib++)
    {
        png_byte junk[1] = { 0 };
        pngcrush_default_read_data(png_ptr, junk, 1);
    }
}

#pragma mark -

png_uint_32 pngcrush_measure_idat(png_structp png_ptr, png_idatp idatp)
{
    png_uint_32 sum_idat_length = 45;
    
    //this is the buffer
    png_byte png_signature[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    
    //read a few bytes into buffer
    pngcrush_default_read_data(png_ptr, png_signature, 8);
    png_set_sig_bytes(png_ptr, 8);
    
    //check first 8 bytes for png signature
    if (!png_sig_cmp(png_signature, 0, 8))
    {
        //is png
        
        if (idatp->salvage)
        {
#ifdef PNG_CRC_WARN_USE
            png_set_crc_action(png_ptr, PNG_CRC_WARN_USE, PNG_CRC_WARN_USE);
#endif
#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
            /* The warning here about deprecated access to png_ptr->zstream
             * is unavoidable.  This will not work with libpng-1.5.x and later.
             */
            inflateUndermine(&png_ptr->zstream, 1);
#endif
        }

        for (;;)
        {
            
            png_byte chunk_name[5];
            png_byte chunk_length[4];
            png_byte buff[32];
            png_uint_32 length;
            
            pngcrush_default_read_data(png_ptr, chunk_length, 4);
            length = pngcrush_get_uint_31(png_ptr,chunk_length);
            
            png_uint_32 pngcrush_crc;
            pngcrush_reset_crc(png_ptr, &pngcrush_crc);
            pngcrush_crc_read(png_ptr, chunk_name, 4, &pngcrush_crc);
            chunk_name[4]='\0';
            
            /* Check for valid chunk name [A-Za-z][A-Za-z][A-Z][A-Za-z] */
            if ( (((chunk_name[0] >= PNGCRUSH_a && chunk_name[0] <= PNGCRUSH_z)  ||
                         (chunk_name[0] >= PNGCRUSH_A && chunk_name[0] <= PNGCRUSH_Z)) &&
                        ((chunk_name[1] >= PNGCRUSH_a && chunk_name[1] <= PNGCRUSH_z)  ||
                         (chunk_name[2] >= PNGCRUSH_A && chunk_name[2] <= PNGCRUSH_Z)) &&
                        ((chunk_name[2] >= PNGCRUSH_A && chunk_name[2] <= PNGCRUSH_Z)) &&
                        ((chunk_name[3] >= PNGCRUSH_a && chunk_name[3] <= PNGCRUSH_z)  ||
                         (chunk_name[3] >= PNGCRUSH_A && chunk_name[3] <= PNGCRUSH_Z))))
            {
                //----------------[acTL]
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_acTL)
                {
                    idatp->found_acTL_chunk = 1;
                }
                
                //----------------[IDAT]
                //----------------[PLTE]
                if ((pngcrush_get_uint_32(chunk_name) == PNG_UINT_IDAT)
                        || (pngcrush_get_uint_32(chunk_name) == PNG_UINT_PLTE))
                {
                    sum_idat_length += (length + 12);
                }
                
                //----------------[CgBI]
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_CgBI)
                {
                    idatp->found_CgBI = 1;
                    idatp->salvage = 1;//for retry
                }
                
                //----------------[IHDR]
                //----------------[dSIG]
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_IHDR)
                {
                    /* get the color type */
                    pngcrush_crc_read(png_ptr, buff, 13, &pngcrush_crc);
                    length -= 13;
                    idatp->input_color_type = buff[9];
                }else if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_dSIG)
                {
                    if (idatp->found_any_chunk == 0 && !idatp->all_chunks_are_safe)
                    {
                        idatp->image_is_immutable = 1;
                    }
                }
                else
                    idatp->found_any_chunk = 1;
                
                //----------------[gAMA]
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_gAMA)
                {
                    idatp->found_gAMA = 1;
                }
                
                //----------------[bKGD]
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_bKGD)
                {
                    if (length == 6)
                    {
                        /* Set found_color_bKGD if the components are different,
                         * so we do not do reduction of color-type from color to gray
                         */
                        pngcrush_crc_read(png_ptr, buff, 6, &pngcrush_crc);
                        length -= 6;
                        if ((buff[0] != buff[2]) && (buff[0] != buff[4]) &&
                                (buff[1] != buff[3]) && (buff[0] != buff[5]))
                            idatp->found_color_bKGD = 1;
                    }
                }
                
                //----------------[cHRM]
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_cHRM)
                {
                    idatp->found_cHRM = 1;
                }
                
                //----------------[hIST]
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_hIST)
                {
                    idatp->found_hIST = 1;
                }
                
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_iCCP)
                {
                    idatp->found_iCCP = 1;
                    
                    /* Check for bad Photoshop iCCP chunk.  Libpng will reject the
                     * bad chunk because the Adler-32 bytes are missing, but we check
                     * here to see if it's really the sRGB profile, and if so, set the
                     * "intent" flag and gamma so pngcrush will write an sRGB chunk
                     * and a gamma chunk.
                     */
                    if (length == 2615)
                    {
                        pngcrush_crc_read(png_ptr, buff, 22, &pngcrush_crc);
                        length -= 22;
                        buff[23] = 0;
                        if (!strncmp((png_const_charp) buff, "Photoshop ICC profile", 21))
                        {
                            //Replacing bad Photoshop iCCP chunk with an sRGB chunk
                            idatp->image_specified_gamma = 45455L;
                            idatp->found_iCCP = 0;
                            idatp->found_sRGB = 1;
                            idatp->intent = 0;
                        }
                    }
                    /* To do: recognize other sRGB iCCP chunks and replace them with
                     * sRGB chunk
                     */
                }
                
                //----------------[sBIT]
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_sBIT)
                {
                    if (length <= 4)
                    {
                        int i;
                        pngcrush_crc_read(png_ptr, buff, length, &pngcrush_crc);
                        idatp->found_sBIT_max = 0;
                        for (i=length; i; i--)
                            if (buff[i] > idatp->found_sBIT_max)
                                idatp->found_sBIT_max=buff[i];
                        
                        if (length > 2)
                            if (buff[0] != buff[1] || buff[0] != buff[2])
                                idatp->found_sBIT_different_RGB_bits = 1;
                        
                        idatp->found_sBIT = 1;
                        length = 0;
                    }
                }
                
                //----------------[tRNS]
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_tRNS)
                {
                    idatp->found_tRNS = 1;
                }
                
                pngcrush_crc_finish(png_ptr, length, &pngcrush_crc);
                
                //----------------[IEND]
                if (pngcrush_get_uint_32(chunk_name) == PNG_UINT_IEND)
                {
                    break;
                }
            }

        }//for
        
    }//is png

    return sum_idat_length;
}

png_uint_32 measure_idats(std::vector<unsigned char> &pictureData, png_idatp idatp)
{
    png_uint_32 measured_idat_length = 0;
    
    png_structp read_ptr = png_create_read_struct(
        PNG_LIBPNG_VER_STRING,
        (png_voidp) NULL,
        (png_error_ptr) NULL,
        (png_error_ptr) NULL);
    
    if (read_ptr)
    {
        png_infop read_info_ptr = png_create_info_struct(read_ptr);
        if(!read_info_ptr)
        {
            png_destroy_read_struct(&read_ptr, NULL, NULL);
        }else
        {
            png_infop end_info_ptr = png_create_info_struct(read_ptr);
            if(!end_info_ptr)
            {
                png_destroy_read_struct(&read_ptr, &read_info_ptr, NULL);
            }else
            {
                PNGData data;
                data.p = &pictureData[0];
                data.len = pictureData.size();
                png_set_read_fn(read_ptr, (png_voidp) &data, (png_rw_ptr) pngcrush_read_png);
                png_set_error_fn(read_ptr, NULL, pngcrush_error, pngcrush_warning);
                png_set_sig_bytes(read_ptr, 0);
                try
                {
                    measured_idat_length = pngcrush_measure_idat(read_ptr, idatp);
                    png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
                }catch(...)
                {
                    measured_idat_length = 0;
                }
            }
        }
    }
    return measured_idat_length;
}

#if defined(PNG_UNKNOWN_CHUNKS_SUPPORTED)
static /* const */ png_byte chunks_to_ignore[] = {
    
    98,  75,  71 , 68, '\0',  /* bKGD */
    99,  72,  82,  77, '\0',  /* cHRM */
    103,  65,  77,  65, '\0',  /* gAMA */
    104,  73,  83,  84, '\0',  /* hIST */
    105,  67,  67,  80, '\0',  /* iCCP */
    105,  84,  88, 116, '\0',  /* iTXt */
    111,  70,  70, 115, '\0',  /* oFFs */
    112,  67,  65,  76, '\0',  /* pCAL */
    112,  72,  89, 115, '\0',  /* pHYs */
    115,  66,  73,  84, '\0',  /* sBIT */
    115,  67,  65,  76, '\0',  /* sCAL */
    115,  80,  76,  84, '\0',  /* sPLT */
    115,  82,  71,  66, '\0',  /* sRGB */
    115,  84,  69,  82, '\0',  /* sTER */
    116,  69,  88, 116, '\0',  /* tEXt */
    116,  73,  77,  69, '\0',  /* tIME */
    116,  82,  78,  83, '\0',  /* tRNS */
    122,  84,  88, 116, '\0'   /* zTXt */
};
#endif

#pragma mark -

bool getPictureDataForType(PackagePtr pParams, int index, std::vector<unsigned char> &buf, std::string &type)
{
    PA_ErrorCode err = eER_NoErr;
    unsigned i = 0;
    PA_Unistring t;
    std::map<CUTF8String, uint32_t> types;
    PA_Picture picture = *(PA_Picture *)(pParams[index - 1]);
    while (err == eER_NoErr)
    {
        t = PA_GetPictureData(picture, ++i, NULL);
        err = PA_GetLastError();
        if(err == eER_NoErr)
        {
            uint32_t len = (uint32_t)(t.fLength * 4) + sizeof(uint8_t);
            std::vector<uint8_t> u(len);
            PA_ConvertCharsetToCharset(
                                                                 (char *)t.fString,
                                                                 t.fLength * sizeof(PA_Unichar),
                                                                 eVTC_UTF_16,
                                                                 (char *)&u[0],
                                                                 len,
                                                                 eVTC_UTF_8
                                                                 );
            CUTF8String uti;
            uti = CUTF8String((const uint8_t *)&u[0]);
            CUTF8String typestring;
            size_t pos, found;
            found = 0;
            for(pos = uti.find(';'); pos != CUTF8String::npos; pos = uti.find(';', found))
            {
                typestring = uti.substr(found, pos-found);
                found = pos + 1;
                types.insert(std::map<CUTF8String, uint32_t>::value_type(typestring, i));
            }
            typestring = uti.substr(found, uti.length()-found);
            types.insert(std::map<CUTF8String, uint32_t>::value_type(typestring, i));
        }
    }
    std::map<CUTF8String, uint32_t>::iterator itr;
    itr = types.find((const uint8_t *)type.c_str());
    if (itr != types.end())
    {
        uint32_t pos = itr->second;
        PA_Handle h = PA_NewHandle(0);
        err = eER_NoErr;
        PA_GetPictureData(picture, pos, h);
        err = PA_GetLastError();
        if(err == eER_NoErr)
        {
            unsigned long insize = PA_GetHandleSize(h);
            buf.resize(insize);
            memcpy(&buf[0], (const void *)PA_LockHandle(h), insize);
            PA_UnlockHandle(h);
            PA_DisposeHandle(h);
            return true;
        }
    }
    return false;
}

#pragma mark -

void pngcrush_setup_methods(std::vector<int> &try_method, std::vector<int> &fm, std::vector<int> &lv, std::vector<int> &zs)
{
    try_method.resize(MAX_METHODSP1);
    fm.resize(MAX_METHODSP1);
    lv.resize(MAX_METHODSP1);
    zs.resize(MAX_METHODSP1);

    for (int i = 0; i < MAX_METHODS; ++i)
    {
        try_method[i] = 1;  /* 1 means do not try this method */
        fm[i] = 5; lv[i] = 9; zs[i] = 1;  /* default:  method 136 */
    }
    for (int i = 0; i <= DEFAULT_METHODS; ++i)
    {
        try_method[i] = 0;
    }
    fm[0] = 0; lv[0] = 0; zs[0] = 0;   /* method  0 == uncompressed */
    fm[1] = 0; lv[1] = 4; zs[1] = 0;   /* method  1 == method  53 */
    fm[2] = 1; lv[2] = 4; zs[2] = 0;   /* method  2 == method  54 */
    lv[3] = 4;              /* method  3 == method  64 */
    fm[4] = 0;                         /* method  4 == method 119 */
    fm[5] = 1;            zs[5] = 0;   /* method  5 == method 114 */
    zs[6] = 0;   /* method  6 == method 118 */
    fm[7] = 0;            zs[7] = 0;   /* method  7 == method 113 */
    fm[8] = 1;                         /* method  8 == method 120 */
    lv[9] = 2; zs[9] = 2;   /* method  9 == method  16 */
    /* method 10 == method 124 */
    /* methods 11 through 16
     *
     * [strategy 2 (Z_HUFFMAN_ONLY) is independent of zlib compression level]
     */
    int method = 11;
    int lev, strat, filt;
    for (filt = 0; filt <= 5; filt++)
    {
        fm[method] = filt;
        lv[method] = 2;
        zs[method] = 2;
        method++;
    }
    /*
     * methods 17 through 136 (10*2*6 = 120)
     */
    for (lev = 1; lev <= 9; lev++)
    {
        for (strat = 0; strat <= 1; strat++)
        {
            for (filt = 0; filt <= 5; filt++)
            {
                fm[method] = filt;
                lv[method] = lev;
                zs[method] = strat;
                method++;
            }
        }
    }
#ifdef Z_RLE
    /* methods 137 through 148
     *
     * [strategy 3 (Z_RLE) is mostly independent of level; 1-3 and 4-9 are
     * same]
     */
    for (filt = 0; filt <= 5; filt++)
    {
        fm[method] = filt;
        lv[method] = 1;
        zs[method] = 3;
        method++;
    }
    for (filt = 0; filt <= 5; filt++)
    {
        fm[method] = filt;
        lv[method] = 4;
        zs[method] = 3;
        method++;
    }
#endif /* Z_RLE */
    for (strat = 0; strat <= 1; strat++)
    {
        for (filt = 0; filt <= 5; filt++)
        {
            fm[method] = filt;
            lv[method] = 0;
            zs[method] = strat;
            method++;
        }
    }
}

#pragma mark -

void Pngcrush(PA_PluginParameters params) {
    
    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_LONGINT Param2;
    C_BLOB png;
    
    Param2.fromParamAtIndex(pParams, 2);
    
    /* get png data */
    std::vector<unsigned char>pictureData;
    std::string type(".png");
    if(getPictureDataForType(pParams, 1, pictureData, type))
    {
        float t_start = (TIME_T) clock();
        float t_stop = 0;
        
        png_idat idat;
        memset(&idat, 0x00, sizeof(idat));
        
        png_uint_32 measured_idat_length = measure_idats(pictureData, &idat);
        
        if(idat.found_CgBI)
            measured_idat_length = measure_idats(pictureData, &idat);//-fix
        
        if(measured_idat_length)
        {
            
            std::vector<int>try_method;
            std::vector<int>fm;
            std::vector<int>lv;
            std::vector<int>zs;
            
            pngcrush_setup_methods(try_method, fm, lv, zs);
            
            int i;
            int trial;
            int last_trial = 0;
            int found_IDAT;
            int force = 1;
            int z_strategy;
            int filter_type, zlib_level;
            int final_method = 0;
            int no_limits = 0;
            int make_8_bit = 1;
            int make_gray = 0;
            int make_opaque = 0;
            int blacken = 0;
            int save_apng_chunks = 0;
            //            int premultiply = 0;
            int force_output_bit_depth = 0;
            //            int found_acTL_chunk = 0;
            int have_bkgd = 0;
            //            int input_color_type = 3;
            png_uint_16 bkgd_red = 0;
            png_uint_16 bkgd_green = 0;
            png_uint_16 bkgd_blue = 0;
            png_byte bkgd_index = 0;
            static int specified_gamma = 0;
            //            static int image_specified_gamma = 0;
            static int force_specified_gamma = 0;
            png_fixed_point file_gamma = 0;
            int double_gamma = 0;
            int iccp_length = 0;
            int resolution = 0;
            int have_trns = 0;
            png_uint_16 trns_index = 0;
            png_uint_16 trns_red = 0;
            png_uint_16 trns_green = 0;
            png_uint_16 trns_blue = 0;
            png_uint_16 trns_gray = 0;
            png_bytep trans;
            int num_trans;
            png_color_16p trans_values;
            int ia;
            png_byte trns_array[256];
            png_byte trans_in[256];
            int num_palette = 0;
            int input_bit_depth = 0;
            char *iccp_text = NULL;
            char iccp_name[80];
            png_colorp palette;
            int text_inputs = 0;
            char text_keyword[11*80+1];
            int text_where[10];
            char text_lang[881];
            char text_lang_key[881];
            char text_text[11*STR_BUF_SIZE+1];
            int text_compression[10];
            int ster_mode = -1;
            int speed = 0;
            int compression_mem_level = 9;
            int compression_window;
            png_alloc_size_t max_bytes;
            //            png_uint_32 max_idat_size = MAX_IDAT_SIZE;
            int default_compression_window = 15;
            int force_compression_window = 0;
            png_bytep row_buf;
            int num_pass;
            float t_misc = 0;
            int pass;
            png_uint_32 y;
            float t_decode = 0;
            float t_encode = 0;
            int best_of_three = 1;
            int bail = 0;
            png_uint_32 pngcrush_write_byte_count;
            png_uint_32 pngcrush_best_byte_count=0xffffffff;
            png_uint_32 idat_length[MAX_METHODSP1];
            idat_length[0] = measured_idat_length;
            
            if (!idat.image_is_immutable)
            {
                int output_color_type = 8;
                int output_bit_depth = 0;
                //                int compression_window = 15;
                
                /*
                 * From the PNG spec, various dependencies among chunk types
                 *   must be accounted for during any reduction of color type
                 *   or bit depth:
                 *
                 * IHDR valid bit depth depends on color type
                 *   valid filter type depends on color type (for MNG extensions)
                 * tRNS depends on color type
                 *   depends on num_palette for color type 3 (palette)
                 * iCCP valid profile depends on color type
                 * sBIT depends on color type and bit depth
                 * bKGD depends on color type and bit depth
                 *
                 */
                //----------------[HIST]; hIST depends on num_palette
                int reduce_palette = 1;
                int plte_len = -1;
                if(idat.input_color_type == 3)
                {
                    if ((idat.found_hIST && (!(Param2.getIntValue() & PNG_REMOVE_HIST))) || idat.found_acTL_chunk == 1)
                    {
                        printf("%s", "Cannot reduce palette length when hIST or acTL chunk is present");
                        reduce_palette = 0;
                        plte_len = -1;
                    }
                    else
                    {
                        try_method[0] = 0;
                        plte_len = 0;
                    }
                }
                for (trial = 0; trial <= MAX_METHODS; ++trial)
                {
                    PA_YieldAbsolute();
                    last_trial = (trial == MAX_METHODS);
                    pngcrush_write_byte_count = 0;
                    found_IDAT = 0;
                    if (trial != 0)
                    {
                        idat_length[trial] = (png_uint_32) 0xffffffff;
                    }/* [0] contains the measured size */
                    /* this part of if-block is for final write-the-best-file iteration */
                    if (trial == MAX_METHODS)
                    {
                        png_uint_32 best_length;
                        int j;
                        /* check lengths */
                        int best = 0;
                        best_length = (png_uint_32) 0xffffffff;
                        for (j = 0; j < MAX_METHODS; j++)
                        {
                            if (best == 0 && best_length == idat_length[j])
                            {
                                /* If no change, report the first match */
                                best = j;
                            }
                            if ((force == 0 || j != 0) && best_length > idat_length[j])
                            {
                                best_length = idat_length[j];
                                best = j;
                            }
                        }
                        if (idat.image_is_immutable || (idat_length[best] == idat_length[0]))
                        {
                            /* just copy input to output */
                            PA_Picture picture = PA_CreatePicture((void *)&pictureData[0], pictureData.size());
                            *(PA_Picture*) pResult = picture;
                            break;
                        }
                        /* get the bast method and zlib level */
                        filter_type = fm[best];
                        zlib_level = lv[best];
                        if (zs[best] == 1)
                            z_strategy = Z_FILTERED;
                        else if (zs[best] == 2)
                            z_strategy = Z_HUFFMAN_ONLY;
                        
                        else if (zs[best] == 3)
                            z_strategy = Z_RLE;
                        
                        else /* if (zs[best] == 0) */
                            z_strategy = Z_DEFAULT_STRATEGY;
                    }
                    else /* Trial < MAX_METHODS */
                    {
                        if (trial > 2 && trial < 5 && idat_length[trial - 1]
                            < idat_length[best_of_three])
                            best_of_three = trial - 1;
                        
                        if (try_method[trial])
                        {
                            continue;
                        }
                        if ((trial == 4 || trial == 7) && best_of_three != 1)
                        {
                            continue;
                        }
                        if ((trial == 5 || trial == 8) && best_of_three != 2)
                        {
                            continue;
                        }
                        if ((trial == 6 || trial == 9 || trial == 10)
                            && best_of_three != 3)
                        {
                            continue;
                        }
                        
                        filter_type = fm[trial];
                        zlib_level = lv[trial];
                        if (zs[trial] == 1)
                            z_strategy = Z_FILTERED;
                        else if (zs[trial] == 2)
                            z_strategy = Z_HUFFMAN_ONLY;
                        
                        else if (zs[trial] == 3)
                            z_strategy = Z_RLE;
                        
                        else /* if (zs[trial] == 0) */
                            z_strategy = Z_DEFAULT_STRATEGY;
                        final_method = trial;
                    }
                    png_structp read_ptr = png_create_read_struct(PNG_LIBPNG_VER_STRING, (png_voidp) NULL, (png_error_ptr) pngcrush_cexcept_error, (png_error_ptr) pngcrush_warning);
                    if(read_ptr)
                    {
                        png_set_benign_errors(read_ptr, 1);
                        if (no_limits == 0)
                        {
                            png_set_user_limits(read_ptr, 500000L, 500000L);
                            png_set_chunk_cache_max(read_ptr, 500);
                            png_set_chunk_malloc_max(read_ptr, 2000000L);
                        }
                        if (idat.salvage)
                        {
                            png_set_option(read_ptr, PNG_MAXIMUM_INFLATE_WINDOW, PNG_OPTION_ON);
                        }
                        /* Change the underlying color of any fully transparent pixel to black.
                         * Remove the alpha channel from any fully-opaque image.
                         * Change any all-gray image to a gray colortype.
                         * Reduce 16-bit image to 8-bit if possible without loss.
                         */
                        png_pixel pixel;
                        pixel.blacken = blacken;
                        pixel.make_gray = make_gray;
                        pixel.make_opaque = make_opaque;
                        pixel.make_8_bit = make_8_bit;
                        pixel.reduce_palette = reduce_palette;
                        pixel.plte_len = plte_len;
                        int user_depth = 0, user_channels = 0;
                        if (trial == 0
                            && (blacken == 1
                                || make_gray == 1
                                || make_opaque == 1
                                || make_8_bit == 1
                                || reduce_palette == 1))
                        {
                            png_set_user_transform_info(read_ptr, &pixel, user_depth, user_channels);
                            png_set_read_user_transform_fn(read_ptr, pngcrush_examine_pixels_fn);
                        }
                        if (last_trial == 0)
                        {
                            png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_NEVER, (png_bytep) NULL, 0);
                            png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_NEVER, chunks_to_ignore, sizeof (chunks_to_ignore)/5);
                        }
                        png_structp write_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING, (png_voidp) NULL, (png_error_ptr) pngcrush_error, (png_error_ptr) pngcrush_warning);
                        if(write_ptr)
                        {
                            png_infop read_info_ptr = png_create_info_struct(read_ptr);
                            if(!read_info_ptr)
                            {
                                break;
                            }else
                            {
                                png_infop end_info_ptr = png_create_info_struct(read_ptr);
                                if(!end_info_ptr)
                                {
                                    png_destroy_read_struct(&read_ptr, &read_info_ptr, NULL);
                                    break;
                                }else
                                {
                                    png_infop write_info_ptr = png_create_info_struct(write_ptr);
                                    if(!write_info_ptr)
                                    {
                                        png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
                                        break;
                                    }else
                                    {
                                        png_infop write_end_info_ptr = png_create_info_struct(write_ptr);
                                        if(!write_end_info_ptr)
                                        {
                                            png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
                                            png_destroy_write_struct(&write_ptr, &write_info_ptr);
                                            break;
                                        }else
                                        {
                                            PNGOutData pngOut;
                                            pngOut.blob = &png;
                                            pngOut.len = 0;
                                            pngOut.last_trial = last_trial;
                                            png_set_write_fn(write_ptr, (png_voidp)&pngOut, pngcrush_write_png, pngcrush_flush);
                                            PNGData pngIn;
                                            pngIn.p = &pictureData[0];
                                            pngIn.len = pictureData.size();
                                            png_set_read_fn(read_ptr, (png_voidp) &pngIn, (png_rw_ptr) pngcrush_read_png);
                                            
                                            /* We don't need to check CRC's because they were already
                                             checked in the pngcrush_measure_idat function */
                                            png_set_crc_action(read_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);
                                            
                                            if (last_trial == 0)
                                            {
                                                /* Only calculate CRC while writing the final output */
                                                png_set_crc_action(write_ptr, PNG_CRC_QUIET_USE, PNG_CRC_QUIET_USE);
                                            }
                                            /* Only run this test (new in libpng-1.5.10) during the
                                             * 0th and last trial
                                             */
                                            if ((idat.input_color_type == 3) &&
                                                ((last_trial && pixel.reduce_palette == 0) ||
                                                 (trial == 0 && pixel.reduce_palette == 1)))
                                            {
                                                png_set_check_for_invalid_index (read_ptr, 1);
                                            }
                                            if (last_trial && output_color_type == 3)
                                            {
                                                png_set_check_for_invalid_index (write_ptr, 1);
                                            }
                                            if (last_trial == 1)
                                            {
                                                png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) NULL, 0);
                                                if (save_apng_chunks == 1)
                                                {
                                                    /* To do: Why use write_ptr not read_ptr here? */
                                                    png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "acTL", 1);
                                                    png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "fcTL", 1);
                                                    png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "fdAT", 1);
                                                }
                                                if (idat.found_any_chunk == 1)
                                                    png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "dSIG", 1);
                                                if (idat.all_chunks_are_safe)
                                                {
                                                    png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) NULL, 0);
                                                    if (save_apng_chunks == 0)
                                                    {
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "acTL", 1);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "fcTL", 1);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, (png_bytep) "fdAT", 1);
                                                    }
                                                }
                                                else
                                                {
                                                    png_byte chunk_name[5];
                                                    chunk_name[4] = '\0';
                                                    /* To do: Why use write_ptr not read_ptr here? */
                                                    if (!Param2.getIntValue())
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_IF_SAFE, (png_bytep) NULL, 0);
                                                    else
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_NEVER, (png_bytep) NULL, 0);
                                                    
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_CHRM))
                                                    {
                                                        pngcrush_save_uint_32(chunk_name, PNG_UINT_cHRM);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
                                                    }
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_HIST))
                                                    {
                                                        pngcrush_save_uint_32(chunk_name, PNG_UINT_hIST);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
                                                    }
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_ICCP))
                                                    {
                                                        pngcrush_save_uint_32(chunk_name, PNG_UINT_iCCP);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
                                                    }
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_ITXT))
                                                    {
                                                        pngcrush_save_uint_32(chunk_name, PNG_UINT_iTXt);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
                                                    }
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_SCAL))
                                                    {
                                                        pngcrush_save_uint_32(chunk_name, PNG_UINT_sCAL);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
                                                    }
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_PCAL))
                                                    {
                                                        pngcrush_save_uint_32(chunk_name, PNG_UINT_pCAL);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
                                                    }
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_SPLT))
                                                    {
                                                        pngcrush_save_uint_32(chunk_name, PNG_UINT_sPLT);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
                                                    }
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_STER))
                                                    {
                                                        pngcrush_save_uint_32(chunk_name, PNG_UINT_sTER);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
                                                    }
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_TIME))
                                                    {
                                                        pngcrush_save_uint_32(chunk_name, PNG_UINT_tIME);
                                                        png_set_keep_unknown_chunks(write_ptr, PNG_HANDLE_CHUNK_ALWAYS, chunk_name, 1);
                                                    }
                                                }
                                                if (idat.salvage && idat.found_CgBI)
                                                {
                                                    /* Skip the CgBI chunk */
                                                    png_skip_chunk(read_ptr);
                                                    /* iCCP and zTXt are probably unreadable
                                                     * because of the nonstandard deflate */
                                                    png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_NEVER, (png_bytep)"iCCP", 1);
                                                    png_set_keep_unknown_chunks(read_ptr, PNG_HANDLE_CHUNK_NEVER, (png_bytep)"zTXt", 1);
                                                }
                                            }
                                            png_read_info(read_ptr, read_info_ptr);
                                            //----------------[ICCP]
                                            //----------------[SBIT]
                                            //----------------[BKGD]
                                            if (trial != 0)
                                            {
                                                if (pixel.make_opaque == 1)
                                                {
                                                    if (output_color_type == 4)
                                                        output_color_type = 0;
                                                    if (output_color_type == 6)
                                                        output_color_type = 2;
                                                }
                                                if (pixel.make_gray == 1)
                                                {
                                                    /* Note: Take care that iCCP, sBIT, and bKGD data are not
                                                     * lost or become invalid when reducing images from
                                                     * truecolor to grayscale or when reducing the bit depth.
                                                     * (To do: test this; it's probably OK)
                                                     */
                                                    /* To do: check bKGD color */
                                                    if (output_color_type == 6)
                                                        output_color_type = 4;
                                                    if (output_color_type == 2)
                                                        output_color_type = 0;
                                                }
                                                if (pixel.make_opaque != 1 && pixel.blacken == 2)
                                                {
                                                    png_set_read_user_transform_fn(read_ptr, pngcrush_transform_pixels_fn);
                                                }
                                            }
                                            
                                            /* Start of chunk-copying/removal code, in order:
                                             *  - IHDR
                                             *  - bKGD
                                             *  - cHRM
                                             *  - gAMA
                                             *  - sRGB
                                             *  - iCCP
                                             *  - oFFs
                                             *  - pCAL
                                             *  - pHYs
                                             *  - hIST
                                             *  - tRNS
                                             *  - PLTE
                                             *  - sBIT
                                             *  - sCAL
                                             *  - sPLT
                                             *  - sTER
                                             *  - tEXt/zTXt/iTXt
                                             *  - tIME
                                             *  - unknown chunks
                                             */
                                            int compression_method, filter_method;
                                            png_uint_32 width, height;
                                            int bit_depth, color_type;
                                            int interlace_method = 0;
                                            
                                            if (png_get_IHDR(read_ptr, read_info_ptr, &width, &height,
                                                             &bit_depth, &color_type, &interlace_method,
                                                             &compression_method, &filter_method))
                                            {
                                                int need_expand = 0;
                                                idat.input_color_type = color_type;
                                                int input_bit_depth = bit_depth;
                                                
                                                if (output_color_type > 7)
                                                {
                                                    output_color_type = idat.input_color_type;
                                                }
                                                
                                                output_bit_depth = input_bit_depth;
                                                
                                                if ((output_color_type != 3 || output_bit_depth > 8)
                                                    && output_bit_depth >= 8
                                                    && output_bit_depth > input_bit_depth)
                                                    need_expand = 1;
                                                
                                                if ((color_type == 2 ||
                                                     color_type == 6 ||
                                                     color_type == 3) &&
                                                    (output_color_type == 0 ||
                                                     output_color_type == 4))
                                                {
                                                    png_set_rgb_to_gray_fixed(read_ptr, 1, 21260, 71520);
                                                    if (output_bit_depth < 8)
                                                        output_bit_depth = 8;
                                                    if (color_type == 3)
                                                        need_expand = 1;
                                                }
                                                if (color_type != 3 && output_color_type == 3)
                                                {
                                                    output_color_type = idat.input_color_type;
                                                }
                                                
                                                if ((color_type == 0 || color_type == 4) &&
                                                    (output_color_type == 2
                                                     || output_color_type == 6))
                                                {
                                                    png_set_gray_to_rgb(read_ptr);
                                                }
                                                
                                                if ((color_type == 4 || color_type == 6) &&
                                                    (output_color_type != 4
                                                     && output_color_type != 6))
                                                {
                                                    png_set_strip_alpha(read_ptr);
                                                }
                                                
                                                if ((output_color_type == 4
                                                     || output_color_type == 6) && (color_type != 4
                                                                                    && color_type != 6))
                                                {
                                                    png_set_filler(read_ptr, (png_uint_32) 65535L, PNG_FILLER_AFTER);
                                                    need_expand = 1;
                                                }
                                                
                                                if (output_color_type != 0 && output_color_type != 3 &&
                                                    output_bit_depth < 8)
                                                    output_bit_depth = 8;
                                                
                                                if ((output_color_type == 2
                                                     || output_color_type == 6)
                                                    && color_type == 3)
                                                {
                                                    need_expand = 1;
                                                }
                                                if (need_expand == 1)
                                                    png_set_expand(read_ptr);
                                                
                                                if (input_bit_depth < 8)
                                                {
                                                    png_set_packing(read_ptr);
                                                }
                                                
                                                if (output_color_type == 0 && output_bit_depth < 8)
                                                {
                                                    png_color_8 true_bits;
                                                    true_bits.gray = (png_byte) (output_bit_depth);
                                                    png_set_shift(read_ptr, &true_bits);
                                                }
                                                
                                                if (trial > 0)
                                                {
                                                    /* TO DO: have we got the right plte_len now? */
                                                    if (pixel.plte_len > 0 && output_color_type == 3 &&
                                                        force_output_bit_depth == 0)
                                                    {
                                                        if (pixel.plte_len <= 2)
                                                            force_output_bit_depth = 1;
                                                        else if (pixel.plte_len <= 4)
                                                            force_output_bit_depth = 2;
                                                        else if (pixel.plte_len <= 16)
                                                            force_output_bit_depth = 4;
                                                        else
                                                            force_output_bit_depth = 8;
                                                    }
                                                    
                                                    if (pixel.make_8_bit == 1)
                                                    {
                                                        output_bit_depth = 8;
                                                        force_output_bit_depth = 8;
                                                        png_set_strip_16(read_ptr);
                                                    }
                                                }
                                                
                                                if (last_trial == 1)
                                                {
                                                    if (save_apng_chunks == 1 || idat.found_acTL_chunk == 1)
                                                    {
                                                        if (idat.input_color_type != output_color_type)
                                                        {
                                                            save_apng_chunks = 2;
                                                        }
                                                        if (input_bit_depth != output_bit_depth)
                                                        {
                                                            save_apng_chunks = 2;
                                                        }
                                                        if (save_apng_chunks != 1 && idat.found_acTL_chunk == 1)
                                                            idat.found_acTL_chunk = 2;
                                                    }
                                                }
                                                
                                                png_set_IHDR(write_ptr, write_info_ptr, width,
                                                             height, output_bit_depth,
                                                             output_color_type, interlace_method,
                                                             compression_method, filter_method);
                                                
                                            } /* IHDR */
                                            /* Handle ancillary chunks */
                                            if (last_trial == 1)
                                            {
                                                png_color_16p background;
                                                if (!have_bkgd && png_get_bKGD(read_ptr, read_info_ptr, &background))
                                                {
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_BKGD))
                                                    {
                                                        if ((idat.input_color_type == 2 ||
                                                             idat.input_color_type == 6) &&
                                                            (output_color_type == 0 ||
                                                             output_color_type == 4))
                                                            background->gray = background->green;
                                                        
                                                        png_set_bKGD(write_ptr, write_info_ptr,
                                                                     background);
                                                    }
                                                }
                                                if (have_bkgd)
                                                {
                                                    /* If we are reducing an RGB image to grayscale, but
                                                     * the background color isn't gray, the green channel
                                                     * is written.  That's not spec-compliant.  We should
                                                     * really check for a non-gray bKGD and refuse to do
                                                     * the reduction if one is present.
                                                     */
                                                    png_color_16 backgd;
                                                    png_color_16p backgrnd = &backgd;
                                                    backgrnd->red = bkgd_red;
                                                    backgrnd->green = bkgd_green;
                                                    backgrnd->blue = bkgd_blue;
                                                    backgrnd->gray = backgrnd->green;
                                                    backgrnd->index = bkgd_index;
                                                    png_set_bKGD(write_ptr, write_info_ptr,
                                                                 backgrnd);
                                                }
                                                
                                                
                                                
#if defined(PNG_READ_cHRM_SUPPORTED) && defined(PNG_WRITE_cHRM_SUPPORTED)
#ifdef PNG_FIXED_POINT_SUPPORTED
                                                {
                                                    png_fixed_point white_x, white_y, red_x, red_y,
                                                    green_x, green_y, blue_x, blue_y;
                                                    
                                                    if (idat.found_cHRM && png_get_cHRM_fixed
                                                        (read_ptr, read_info_ptr, &white_x, &white_y,
                                                         &red_x, &red_y, &green_x, &green_y, &blue_x,
                                                         &blue_y))
                                                    {
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_CHRM))
                                                        {
                                                            png_set_cHRM_fixed(write_ptr,
                                                                               write_info_ptr, white_x,
                                                                               white_y, red_x, red_y,
                                                                               green_x, green_y,
                                                                               blue_x, blue_y);
                                                        }
                                                    }
                                                }
#else
                                                {
                                                    double white_x, white_y, red_x, red_y, green_x,
                                                    green_y, blue_x, blue_y;
                                                    
                                                    if (idat.found_cHRM && png_get_cHRM
                                                        (read_ptr, read_info_ptr, &white_x, &white_y,
                                                         &red_x, &red_y, &green_x, &green_y, &blue_x,
                                                         &blue_y)) {
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_CHRM))
                                                        {
                                                            png_set_cHRM(write_ptr, write_info_ptr,
                                                                         white_x, white_y, red_x,
                                                                         red_y, green_x, green_y,
                                                                         blue_x, blue_y);
                                                        }
                                                    }
                                                }
#endif /* PNG_FIXED_POINT_SUPPORTED */
#endif /* PNG_READ_cHRM_SUPPORTED && PNG_WRITE_cHRM_SUPPORTED */
                                                
#if defined(PNG_READ_gAMA_SUPPORTED) && defined(PNG_WRITE_gAMA_SUPPORTED)
                                                {
                                                    if (force_specified_gamma)
                                                    {
#ifdef PNG_FIXED_POINT_SUPPORTED
                                                        png_set_gAMA_fixed(write_ptr, write_info_ptr,
                                                                           (png_fixed_point)
                                                                           force_specified_gamma);
                                                        file_gamma =
                                                        (png_fixed_point) force_specified_gamma;
#else
                                                        png_set_gAMA(write_ptr, write_info_ptr,
                                                                     force_specified_gamma);
                                                        file_gamma = force_specified_gamma;
#endif
                                                    }
#ifdef PNG_FIXED_POINT_SUPPORTED
                                                    else if (idat.found_gAMA && png_get_gAMA_fixed
                                                             (read_ptr, read_info_ptr, &file_gamma))
#else
                                                        else if (idat.found_gAMA && idat.png_get_gAMA
                                                                 (read_ptr, read_info_ptr, &file_gamma))
#endif
                                                        {
                                                            if (!(Param2.getIntValue() & PNG_REMOVE_GAMA))
                                                            {
                                                                if (idat.image_specified_gamma)
                                                                    file_gamma = idat.image_specified_gamma;
                                                                if (last_trial)
#ifdef PNG_FIXED_POINT_SUPPORTED
                                                                    if (double_gamma)
                                                                        file_gamma += file_gamma;
                                                                png_set_gAMA_fixed(write_ptr, write_info_ptr,
                                                                                   file_gamma);
#else
                                                                if (double_gamma)
                                                                    file_gamma += file_gamma;
                                                                png_set_gAMA(write_ptr, write_info_ptr,
                                                                             file_gamma);
#endif
                                                            }
                                                        }
                                                        else if (specified_gamma)
                                                        {
#ifdef PNG_FIXED_POINT_SUPPORTED
                                                            png_set_gAMA_fixed(write_ptr, write_info_ptr,
                                                                               specified_gamma);
                                                            file_gamma = (png_fixed_point) specified_gamma;
#else
                                                            png_set_gAMA(write_ptr, write_info_ptr,
                                                                         specified_gamma);
                                                            file_gamma = specified_gamma;
#endif
                                                        }
                                                }
#endif /* PNG_READ_gAMA_SUPPORTED && PNG_WRITE_gAMA_SUPPORTED */
                                                
#if defined(PNG_READ_sRGB_SUPPORTED) && defined(PNG_WRITE_sRGB_SUPPORTED)
                                                {
                                                    int file_intent;
                                                    
                                                    if (png_get_sRGB
                                                        (read_ptr, read_info_ptr, &file_intent))
                                                    {
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_SRGB))
                                                        {
                                                            png_set_sRGB(write_ptr, write_info_ptr,
                                                                         file_intent);
                                                            idat.intent = file_intent;
                                                        }
                                                    }
                                                    else if (idat.found_sRGB)
                                                    {
#ifdef PNG_gAMA_SUPPORTED
#  ifdef PNG_FIXED_POINT_SUPPORTED
                                                        if (file_gamma >= 45000L && file_gamma <= 46000L)
#  else
                                                            if (file_gamma >= 0.45000 && file_gamma <= 0.46000)
#  endif
                                                            {
                                                                png_set_sRGB(write_ptr, write_info_ptr, idat.intent);
                                                            }
#endif /* PNG_gAMA_SUPPORTED */
                                                    }
                                                }
#endif /* PNG_READ_sRGB_SUPPORTED && PNG_WRITE_sRGB_SUPPORTED */
                                                
#if defined(PNG_READ_iCCP_SUPPORTED) && defined(PNG_WRITE_iCCP_SUPPORTED)
                                                if (idat.intent < 0) {  /* ignore iCCP if sRGB is being written */
                                                    png_charp name;
#if PNGCRUSH_LIBPNG_VER < 10500
                                                    png_charp profile;
#else
                                                    png_bytep profile;
#endif
                                                    png_uint_32 proflen;
                                                    int compression_method;
                                                    
                                                    if (idat.found_iCCP && png_get_iCCP((png_const_structrp)read_ptr,
                                                                                        (png_inforp)read_info_ptr,
                                                                                        (png_charpp)&name,
                                                                                        (int *)&compression_method,
                                                                                        (png_bytepp)&profile,
                                                                                        (png_uint_32 *)&proflen))
                                                    {
                                                        
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_ICCP))
                                                            png_set_iCCP((png_const_structrp)write_ptr,
                                                                         (png_inforp)write_info_ptr,
                                                                         (png_const_charp)name,
                                                                         (int)compression_method,
                                                                         (png_const_bytep)profile,
                                                                         (png_uint_32)proflen);
                                                    }
#ifdef PNG_iCCP_SUPPORTED
                                                    else if (iccp_length)
                                                    {
                                                        png_set_iCCP((png_const_structrp)write_ptr,
                                                                     (png_inforp)write_info_ptr,
                                                                     (png_const_charp)iccp_name,
                                                                     (int)0,
                                                                     (png_const_bytep) iccp_text,
                                                                     (png_uint_32)iccp_length);
                                                    }
#endif /* PNG_iCCP_SUPPORTED */
                                                    
                                                }
#endif /* PNG_READ_iCCP_SUPPORTED && PNG_WRITE_iCCP_SUPPORTED */
                                                
#if defined(PNG_READ_oFFs_SUPPORTED) && defined(PNG_WRITE_oFFs_SUPPORTED)
                                                {
                                                    png_int_32 offset_x, offset_y;
                                                    int unit_type;
                                                    
                                                    if (png_get_oFFs
                                                        (read_ptr, read_info_ptr, &offset_x, &offset_y,
                                                         &unit_type)) {
                                                        if (!(offset_x == 0 && offset_y == 0))
                                                        {
                                                            if (!(Param2.getIntValue() & PNG_REMOVE_OFFS))
                                                                png_set_oFFs(write_ptr, write_info_ptr,
                                                                             offset_x, offset_y,
                                                                             unit_type);
                                                        }
                                                    }
                                                }
#endif /* PNG_READ_oFFs_SUPPORTED && PNG_WRITE_oFFs_SUPPORTED */
                                                
#if defined(PNG_READ_pCAL_SUPPORTED) && defined(PNG_WRITE_pCAL_SUPPORTED)
                                                {
                                                    png_charp purpose, units;
                                                    png_charpp params;
                                                    png_int_32 X0, X1;
                                                    int type, nparams;
                                                    
                                                    if (png_get_pCAL
                                                        (read_ptr, read_info_ptr, &purpose, &X0, &X1,
                                                         &type, &nparams, &units, &params))
                                                    {
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_PCAL))
                                                            png_set_pCAL(write_ptr, write_info_ptr,
                                                                         purpose, X0, X1, type, nparams,
                                                                         units, params);
                                                    }
                                                }
#endif /* pCAL_SUPPORTED */
                                                
#if defined(PNG_READ_pHYs_SUPPORTED) && defined(PNG_WRITE_pHYs_SUPPORTED)
                                                {
                                                    png_uint_32 res_x, res_y;
                                                    int unit_type;
                                                    
                                                    if (resolution == 0)
                                                    {
                                                        if (png_get_pHYs
                                                            (read_ptr, read_info_ptr, &res_x, &res_y,
                                                             &unit_type))
                                                        {
                                                            if (!(res_x == 0 && res_y == 0))
                                                            {
                                                                if (!(Param2.getIntValue() & PNG_REMOVE_PHYS))
                                                                    png_set_pHYs(write_ptr, write_info_ptr,
                                                                                 res_x, res_y, unit_type);
                                                            }
                                                        }
                                                    } else {
                                                        unit_type = 1;
                                                        res_x = res_y =
                                                        (png_uint_32) ((resolution / .0254 + 0.5));
                                                        png_set_pHYs(write_ptr, write_info_ptr, res_x, res_y, unit_type);
                                                    }
                                                }
#endif
                                                
#if defined(PNG_READ_hIST_SUPPORTED) && defined(PNG_WRITE_hIST_SUPPORTED)
                                                {
                                                    png_uint_16p hist;
                                                    
                                                    if (png_get_hIST(read_ptr, read_info_ptr, &hist))
                                                    {
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_HIST))
                                                            png_set_hIST(write_ptr, write_info_ptr, hist);
                                                    }
                                                }
#endif /* hIST_SUPPORTED */
                                                
#if defined(PNG_READ_tRNS_SUPPORTED) && defined(PNG_WRITE_tRNS_SUPPORTED)
                                                {
                                                    if (png_get_tRNS
                                                        (read_ptr, read_info_ptr, &trans, &num_trans,
                                                         &trans_values))
                                                    {
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_TRNS))
                                                        {
                                                            int last_nonmax = -1;
                                                            trns_red = trans_values->red;
                                                            trns_green = trans_values->green;
                                                            trns_blue = trans_values->blue;
                                                            trns_gray = trans_values->gray;
                                                            if (output_color_type == 3)
                                                            {
                                                                for (ia = 0; ia < num_trans; ia++)
                                                                    trns_array[ia] = trans[ia];
                                                                for (; ia < 256; ia++)
                                                                    trns_array[ia] = 255;
                                                                for (ia = 0; ia < 256; ia++)
                                                                {
                                                                    if (trns_array[ia] != 255)
                                                                        last_nonmax = ia;
                                                                }
                                                                num_trans = last_nonmax + 1;
                                                            }
                                                            else
                                                            {
                                                                /* color type is 0 or 2 */
                                                                if (input_bit_depth == 16 &&
                                                                    output_bit_depth == 8)
                                                                {
                                                                    /* zero out the high byte */
                                                                    trans_values->red &= 0x00ff;
                                                                    trans_values->green &= 0x00ff;
                                                                    trans_values->blue &= 0x00ff;
                                                                    trans_values->gray &= 0x00ff;
                                                                }
                                                                
                                                            }
                                                            if (output_color_type < 3 || num_trans)
                                                                png_set_tRNS(write_ptr, write_info_ptr, trans, num_trans, trans_values);
                                                        }
                                                    }
                                                    else if (have_trns == 1)
                                                    {
                                                        /* will not overwrite existing trns data */
                                                        png_color_16 trans_data;
                                                        png_byte index_data = (png_byte) trns_index;
                                                        num_trans = index_data + 1;
                                                        if (output_color_type == 3)
                                                        {
                                                            trans_values = NULL;
                                                            for (ia = 0; ia < num_trans; ia++)
                                                                trns_array[ia] = trans_in[ia];
                                                            for (; ia < 256; ia++)
                                                                trns_array[ia] = 255;
                                                        } else {
                                                            for (ia = 0; ia < 256; ia++)
                                                                trns_array[ia] = 255;
                                                            trns_array[index_data] = 0;
                                                            
                                                            trans_data.index = index_data;
                                                            trans_data.red = trns_red;
                                                            trans_data.green = trns_green;
                                                            trans_data.blue = trns_blue;
                                                            trans_data.gray = trns_gray;
                                                            trans_values = &trans_data;
                                                        }
                                                        png_set_tRNS(write_ptr, write_info_ptr, trns_array, num_trans, trans_values);
                                                    }
                                                    else
                                                    {
                                                        for (ia = 0; ia < 256; ia++)
                                                            trns_array[ia] = 255;
                                                    }
                                                    if (last_trial)
                                                    {
                                                        int last = -1;
                                                        for (ia = 0; ia < num_palette; ia++)
                                                            if (trns_array[ia] != 255)
                                                                last = ia;
                                                    }
                                                }
#endif /* PNG_READ_tRNS_SUPPORTED && PNG_WRITE_tRNS_SUPPORTED */
                                            }  /* End of ancillary chunk handling */
                                            if (png_get_PLTE(read_ptr, read_info_ptr, &palette, &num_palette))
                                            {
                                                if (pixel.plte_len > 0)
                                                    num_palette = pixel.plte_len;
                                                
                                                if (output_color_type == 3)
                                                    png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
                                                else if (!(Param2.getIntValue() & PNG_REMOVE_PLTE))
                                                    png_set_PLTE(write_ptr, write_info_ptr, palette, num_palette);
                                                
                                                if (last_trial)
                                                {
                                                    png_colorp p = palette;
                                                    for (i = 0; i < num_palette; i++)
                                                    {
                                                        p++;
                                                    }
                                                }
                                            }
                                            /* Handle ancillary chunks */
                                            if (last_trial == 1)
                                            {
#if defined(PNG_READ_sBIT_SUPPORTED) && defined(PNG_WRITE_sBIT_SUPPORTED)
                                                {
                                                    png_color_8p sig_bit;
                                                    
                                                    /* If we are reducing a truecolor PNG to grayscale, and the
                                                     * RGB sBIT values aren't identical, we'll lose sBIT info.
                                                     */
                                                    if (png_get_sBIT(read_ptr, read_info_ptr, &sig_bit))
                                                    {
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_SBIT))
                                                        {
                                                            if ((idat.input_color_type == 0
                                                                 || idat.input_color_type == 4)
                                                                && (output_color_type == 2
                                                                    || output_color_type == 6
                                                                    || output_color_type == 3))
                                                                sig_bit->red = sig_bit->green =
                                                                sig_bit->blue = sig_bit->gray;
                                                            if ((idat.input_color_type == 2
                                                                 || idat.input_color_type == 6
                                                                 || output_color_type == 3)
                                                                && (output_color_type == 0
                                                                    || output_color_type == 4))
                                                                sig_bit->gray = sig_bit->green;
                                                            
                                                            if ((idat.input_color_type == 0
                                                                 || idat.input_color_type == 2)
                                                                && (output_color_type == 4
                                                                    || output_color_type == 6))
                                                                sig_bit->alpha = 1;
                                                            
                                                            png_set_sBIT(write_ptr, write_info_ptr,
                                                                         sig_bit);
                                                        }
                                                    }
                                                }
#endif /* PNG_READ_sBIT_SUPPORTED)&& PNG_WRITE_sBIT_SUPPORTED */
                                                
#ifdef PNG_sCAL_SUPPORTED
#  ifdef PNG_FLOATING_POINT_SUPPORTED
                                                {
                                                    int unit;
                                                    double scal_width, scal_height;
                                                    
                                                    if (png_get_sCAL
                                                        (read_ptr, read_info_ptr, &unit, &scal_width,
                                                         &scal_height))
                                                    {
                                                        png_set_sCAL(write_ptr, write_info_ptr, unit,
                                                                     scal_width, scal_height);
                                                    }
                                                }
#  else
#    ifdef PNG_FIXED_POINT_SUPPORTED
                                                {
                                                    int unit;
                                                    png_charp scal_width, scal_height;
                                                    
                                                    if (png_get_sCAL_s
                                                        (read_ptr, read_info_ptr, &unit, &scal_width,
                                                         &scal_height))
                                                    {
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_SCAL))
                                                            png_set_sCAL_s(write_ptr, write_info_ptr, unit,
                                                                           scal_width, scal_height);
                                                    }
                                                }
#    endif
#  endif /* PNG_FLOATING_POINT_SUPPORTED */
#endif /* PNG_sCAL_SUPPORTED */
                                                
#ifdef PNG_sPLT_SUPPORTED
                                                {
                                                    png_sPLT_tp entries;
                                                    int num_entries;
                                                    
                                                    num_entries =
                                                    (int) png_get_sPLT(read_ptr, read_info_ptr,
                                                                       &entries);
                                                    if (num_entries)
                                                    {
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_SPLT))
                                                            png_set_sPLT(write_ptr, write_info_ptr,
                                                                         entries, num_entries);
                                                    }
                                                }
#endif
                                                
#ifdef PNG_TEXT_SUPPORTED
                                                {
                                                    png_textp text_ptr;
                                                    int num_text = 0;
                                                    
                                                    if (png_get_text
                                                        (read_ptr, read_info_ptr, &text_ptr, &num_text) > 0
                                                        || text_inputs)
                                                    {
                                                        int ntext;
                                                        if (num_text > 0)
                                                        {
                                                            if (!(Param2.getIntValue() & PNG_REMOVE_TEXT))
                                                            {
                                                                int num_to_write = num_text;
                                                                for (ntext = 0; ntext < num_text; ntext++)
                                                                {
                                                                    if (text_ptr[ntext].compression ==
                                                                        PNG_TEXT_COMPRESSION_NONE) {
                                                                        if (Param2.getIntValue() & PNG_REMOVE_TEXT)
                                                                        {
                                                                            text_ptr[ntext].key[0] = '\0';
                                                                            num_to_write--;
                                                                        }
                                                                    }
                                                                    if (text_ptr[ntext].compression ==
                                                                        PNG_TEXT_COMPRESSION_zTXt)
                                                                    {
                                                                        if (Param2.getIntValue() & PNG_REMOVE_ZTXT)
                                                                        {
                                                                            text_ptr[ntext].key[0] = '\0';
                                                                            num_to_write--;
                                                                        }
                                                                    }
#ifdef PNG_iTXt_SUPPORTED
                                                                    if (text_ptr[ntext].compression ==
                                                                        PNG_ITXT_COMPRESSION_NONE
                                                                        || text_ptr[ntext].compression ==
                                                                        PNG_ITXT_COMPRESSION_zTXt)
                                                                    {
                                                                        if (Param2.getIntValue() & PNG_REMOVE_ITXT)
                                                                        {
                                                                            text_ptr[ntext].key[0] = '\0';
                                                                            num_to_write--;
                                                                        }
                                                                    }
#endif
                                                                }
                                                                if (num_to_write > 0)
                                                                    png_set_text(write_ptr, write_info_ptr,
                                                                                 text_ptr, num_text);
                                                            }
                                                        }
                                                        for (ntext = 0; ntext < text_inputs; ntext++)
                                                        {
                                                            if (text_where[ntext] == 1)
                                                            {
                                                                png_textp added_text;
                                                                added_text = (png_textp) png_malloc(write_ptr, (png_uint_32) sizeof(png_text));
                                                                added_text[0].key = &text_keyword[ntext * 80];
#ifdef PNG_iTXt_SUPPORTED
                                                                added_text[0].lang = &text_lang[ntext * 80];
                                                                added_text[0].lang_key =
                                                                &text_lang_key[ntext * 80];
#endif
                                                                added_text[0].text =
                                                                &text_text[ntext * STR_BUF_SIZE];
                                                                added_text[0].compression =
                                                                text_compression[ntext];
                                                                png_set_text(write_ptr, write_info_ptr, added_text, 1);
                                                                png_free(write_ptr, added_text);
                                                                added_text = (png_textp) NULL;
                                                            }
                                                        }
                                                    }
                                                }
#endif /* defined(PNG_TEXT_SUPPORTED) */
                                                
#if defined(PNG_READ_tIME_SUPPORTED) && defined(PNG_WRITE_tIME_SUPPORTED)
                                                {
                                                    png_timep mod_time;
                                                    if (png_get_tIME(read_ptr, read_info_ptr, &mod_time))
                                                    {
                                                        if (!(Param2.getIntValue() & PNG_REMOVE_TIME))
                                                            png_set_tIME(write_ptr, write_info_ptr, mod_time);
                                                    }
                                                }
#endif
#ifdef PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED
                                                /* This section handles pCAL and tIME (at least, in default
                                                 * build), gIFx/gIFg/gIFt, private Fireworks chunks, etc. */
                                                {
                                                    png_unknown_chunkp unknowns;   /* allocated by libpng */
                                                    int num_unknowns;
                                                    num_unknowns = (int)png_get_unknown_chunks(read_ptr, read_info_ptr, &unknowns);
                                                    if (ster_mode >= 0)
                                                    {
                                                        /* Add sTER chunk */
                                                        png_unknown_chunkp ster;
                                                        ster = (png_unknown_chunk*)png_malloc(read_ptr, (png_uint_32) sizeof(png_unknown_chunk));
                                                        png_memcpy((char *)ster[0].name, "sTER",5);
                                                        ster[0].size = 1;
                                                        ster[0].data = (png_byte*)png_malloc(read_ptr, 1);
                                                        ster[0].data[0] = (png_byte)ster_mode;
                                                        png_set_unknown_chunks(read_ptr, read_info_ptr, ster, 1);
                                                        png_free(read_ptr,ster[0].data);
                                                        png_free(read_ptr,ster);
                                                        num_unknowns++;
                                                    }
                                                    
                                                    if (ster_mode >= 0)
                                                        png_set_unknown_chunk_location(read_ptr, read_info_ptr, num_unknowns - 1, (int)PNG_HAVE_IHDR);
                                                    
                                                }
#endif /* PNG_WRITE_UNKNOWN_CHUNKS_SUPPORTED */
                                            }  /* End of ancillary chunk handling */
                                            /*
                                             * Would be useful to have a libpng fix, that either exports
                                             * png_read_transform_info() or provides a generic API that
                                             * can set any png_ptr->flag, or, simpler, provides an API
                                             * to set the PNG_FLAG_ROW_INIT flag.
                                             *
                                             * Starting in libpng-1.5.6beta06, png_read_update_info()
                                             * does not check the PNG_FLAG_ROW_INIT flag and does not
                                             * initialize the row or issue a warning.
                                             *
                                             */
#ifdef PNGCRUSH_H
                                            png_read_transform_info(read_ptr, read_info_ptr);
#else
                                            /* Some pngcrush capabilities are lacking when the system
                                             * libpng is used instead of the one bundled with pngcrush
                                             *
                                             * To do: list those capabilities here
                                             */
                                            
                                            /* pngcrush fails to read interlaced PNGs properly
                                             * when png_read_update_info() is called here.
                                             */
                                            
                                            /* png_read_update_info(read_ptr, read_info_ptr); */
                                            
                                            /* Workaround is to multiply rowbytes by 8/bit_depth
                                             * to allow for unpacking, wherever we allocate a
                                             * row buffer.  This results in too large a value for
                                             * rowbytes under some conditions, e.g., when increasing
                                             * a sub-8-bit file to RGBA, but this is rare and harmless.
                                             */
#endif
                                            if (filter_type == 0)
                                                png_set_filter(write_ptr, 0, PNG_FILTER_NONE);
                                            else if (filter_type == 1)
                                                png_set_filter(write_ptr, 0, PNG_FILTER_SUB);
                                            else if (filter_type == 2)
                                                png_set_filter(write_ptr, 0, PNG_FILTER_UP);
                                            else if (filter_type == 3)
                                                png_set_filter(write_ptr, 0, PNG_FILTER_AVG);
                                            else if (filter_type == 4)
                                                png_set_filter(write_ptr, 0, PNG_FILTER_PAETH);
                                            else if (filter_type == 5)
                                            {
                                                if (speed)
                                                {
                                                    png_set_filter(write_ptr, 0, PNG_FILTER_NONE |
                                                                   PNG_FILTER_SUB | PNG_FILTER_UP);
                                                }
                                                else
                                                {
                                                    png_set_filter(write_ptr, 0, PNG_ALL_FILTERS);
                                                }
                                            }
                                            else
                                                png_set_filter(write_ptr, 0, PNG_FILTER_NONE);
                                            
                                            {
                                                //                                                png_uint_32 zbuf_size;
                                                png_uint_32 required_window;
                                                int channels = 0;
                                                png_set_compression_strategy(write_ptr, z_strategy);
                                                png_set_compression_mem_level(write_ptr, compression_mem_level);
                                                if (output_color_type == 0)
                                                    channels = 1;
                                                if (output_color_type == 2)
                                                    channels = 3;
                                                if (output_color_type == 3)
                                                    channels = 1;
                                                if (output_color_type == 4)
                                                    channels = 2;
                                                if (output_color_type == 6)
                                                    channels = 4;
                                                /* This method was copied from libpng to find maximum
                                                 * data size.  Only return sizes up to the maximum of
                                                 * a png_uint_32, by limiting the width and height used
                                                 * to 15 bits.
                                                 */
                                                png_uint_32 rowbytes;
                                                png_uint_32 h = height;
                                                /* FIX THIS, does not work with libpng-1.7.0
                                                 * because info_ptr->bit_depth has not been
                                                 * updated yet.
                                                 */
                                                rowbytes = png_get_rowbytes(read_ptr, read_info_ptr);
                                                if (rowbytes < 16384 && h < 16384)
                                                {
                                                    if (rowbytes * h < 16384)
                                                    {
                                                        if (interlace_method)
                                                        {
                                                            /* Interlacing makes the uncompressed data
                                                             * larger because of the replication of both
                                                             * the filter byte and the padding to a byte
                                                             * boundary.
                                                             */
                                                            png_uint_32 w = width;
                                                            unsigned int pd = channels * output_bit_depth;
                                                            png_alloc_size_t cb_base;
                                                            int interlace_pass;
                                                            for (cb_base=0, interlace_pass=0; interlace_pass<=6; ++interlace_pass)
                                                            {
                                                                png_uint_32 pw = PNG_PASS_COLS(w, interlace_pass);
                                                                if (pw > 0)
                                                                    cb_base += (PNGCRUSH_ROWBYTES(pd, pw)+1) * PNG_PASS_ROWS(h, interlace_pass);
                                                            }
                                                            max_bytes = cb_base;
                                                        }
                                                        else
                                                            //!interlace_method
                                                            max_bytes = (rowbytes+1) * h;
                                                    }
                                                    else
                                                        //!(rowbytes * h < 16384)
                                                        max_bytes = 0x3fffffffU;
                                                }
                                                else
                                                    //!(rowbytes < 16384 && h < 16384)
                                                    max_bytes = 0x3fffffffU;
                                                
                                                required_window = (png_uint_32) (max_bytes + 262);
                                                //bad calculation, ends up in memory error
                                                /* reinitialize zbuf - compression buffer */
                                                /*
                                                 zbuf_size = png_get_compression_buffer_size(write_ptr);
                                                 if (zbuf_size != max_idat_size)
                                                 {
                                                 png_uint_32 max_possible_size = required_window;
                                                 png_set_compression_buffer_size(write_ptr, max_possible_size);
                                                 }
                                                 */
                                                if (required_window <= 512)
                                                    compression_window = 9;
                                                else if (required_window <= 1024)
                                                    compression_window = 10;
                                                else if (required_window <= 2048)
                                                    compression_window = 11;
                                                else if (required_window <= 4096)
                                                    compression_window = 12;
                                                else if (required_window <= 8192)
                                                    compression_window = 13;
                                                else if (required_window <= 16384)
                                                    compression_window = 14;
                                                else
                                                    compression_window = 15;
                                                if (compression_window > default_compression_window || force_compression_window)
                                                    compression_window = default_compression_window;
                                                
                                                png_set_compression_window_bits(write_ptr, compression_window);
                                            }
                                            png_set_compression_level(write_ptr, zlib_level);
                                            png_write_info(write_ptr, write_info_ptr);
                                            if (output_bit_depth < 8)
                                            {
                                                if (output_color_type == 0)
                                                {
                                                    png_color_8 true_bits;
                                                    true_bits.gray = (png_byte) (output_bit_depth);
                                                    png_set_shift(write_ptr, &true_bits);
                                                }
                                                png_set_packing(write_ptr);
                                            }
                                            png_uint_32 rowbytes_s;
                                            png_uint_32 rowbytes;
                                            rowbytes = png_get_rowbytes(read_ptr, read_info_ptr);
                                            rowbytes_s = (png_size_t) rowbytes;
                                            if (rowbytes == (png_uint_32) rowbytes_s)
                                            {
                                                row_buf = (png_bytep)png_malloc(read_ptr, rowbytes + 64);
                                            }
                                            else
                                            {
                                                row_buf = NULL;
                                            }
                                            num_pass = png_set_interlace_handling(read_ptr);
                                            png_set_interlace_handling(write_ptr);
                                            t_stop = (TIME_T) clock();
                                            t_misc += (t_stop - t_start);
                                            if (t_stop < t_start)
                                            {
                                                t_misc += PNG_UINT_31_MAX;
                                                if (t_stop < 0)
                                                    t_misc += PNG_UINT_31_MAX;
                                            }
                                            t_start = t_stop;
                                            for (pass = 0; pass < num_pass; pass++)
                                            {
                                                for (y = 0; y < height; y++)
                                                {
                                                    png_read_row(read_ptr, row_buf, (png_bytep) NULL);
                                                    t_stop = (TIME_T) clock();
                                                    t_decode += (t_stop - t_start);
                                                    if (t_stop < t_start)
                                                    {
                                                        t_decode += PNG_UINT_31_MAX;
                                                        if (t_stop < 0)
                                                            t_decode += PNG_UINT_31_MAX;
                                                    }
                                                    t_start = t_stop;
                                                    /* To do: zero the padding bits */
                                                    png_write_row(write_ptr, row_buf);
                                                    pngcrush_write_byte_count = pngOut.len;
                                                    t_stop = (TIME_T) clock();
                                                    t_encode += (t_stop - t_start);
                                                    if (t_stop < t_start)
                                                    {
                                                        t_encode += PNG_UINT_31_MAX;
                                                        if (t_stop < 0)
                                                            t_encode += PNG_UINT_31_MAX;
                                                    }
                                                    t_start = t_stop;
                                                    
                                                    /* Bail if byte count exceeds best so far */
                                                    if (bail == 0 && trial != MAX_METHODS &&
                                                        pngcrush_write_byte_count >
                                                        pngcrush_best_byte_count)
                                                    {
                                                        png_write_flush(write_ptr);
                                                        break;
                                                    }
                                                }
                                                if (bail == 0 && trial != MAX_METHODS &&
                                                    pngcrush_write_byte_count >
                                                    pngcrush_best_byte_count)
                                                    break;
                                            }
                                            if (color_type == 3)
                                            {
                                                if (trial == 0 && pixel.reduce_palette == 1)
                                                {
                                                    int palette_length = pixel.plte_len;
                                                    {
                                                        png_color_16p bkgd;
                                                        if (png_get_bKGD(read_ptr, read_info_ptr, &bkgd))
                                                        {
                                                            bkgd_index = bkgd->index;
                                                            if (bkgd_index > palette_length)
                                                            {
                                                                bkgd_index = palette_length;
                                                                have_bkgd = 1;
                                                            }
                                                            if (bkgd->index >= palette_length)
                                                                palette_length = (int) bkgd_index+1;
                                                        }
                                                    }
                                                    pixel.plte_len = palette_length;
                                                    if (num_trans > pixel.plte_len)
                                                    {
                                                        num_trans = pixel.plte_len;
                                                        png_set_tRNS(write_ptr, write_info_ptr, trns_array, num_trans, trans_values);
                                                    }
                                                }
                                            }
                                            t_stop = (TIME_T) clock();
                                            t_decode += (t_stop - t_start);
                                            if (t_stop < t_start)
                                            {
                                                t_decode += PNG_UINT_31_MAX;
                                                if (t_stop < 0)
                                                    t_decode += PNG_UINT_31_MAX;
                                            }
                                            t_start = t_stop;
                                            png_free_data(read_ptr, read_info_ptr, PNG_FREE_UNKN, -1);
                                            png_free_data(write_ptr, write_info_ptr, PNG_FREE_UNKN, -1);
                                            if (!(bail == 0 && trial != MAX_METHODS && pngOut.len > pngcrush_best_byte_count))
                                            {
                                                png_read_end(read_ptr, end_info_ptr);
                                                /* Handle ancillary chunks */
                                                if (last_trial == 1)
                                                {
                                                    png_textp text_ptr;
                                                    int num_text = 0;
                                                    if (png_get_text (read_ptr, end_info_ptr, &text_ptr, &num_text) > 0 || text_inputs)
                                                    {
                                                        int ntext;
                                                        if (last_trial)
                                                        {
                                                            if (num_text > 0)
                                                            {
                                                                if (!(Param2.getIntValue() & PNG_REMOVE_TEXT))
                                                                {
                                                                    int num_to_write = num_text;
                                                                    for (ntext = 0; ntext < num_text; ntext++)
                                                                    {
                                                                        if (text_ptr[ntext].compression == PNG_TEXT_COMPRESSION_NONE)
                                                                        {
                                                                            if (Param2.getIntValue() & PNG_REMOVE_TIME)
                                                                            {
                                                                                text_ptr[ntext].key[0] = '\0';
                                                                                num_to_write--;
                                                                            }
                                                                        }
                                                                        if (text_ptr[ntext].compression == PNG_TEXT_COMPRESSION_zTXt)
                                                                        {
                                                                            if (!(Param2.getIntValue() & PNG_REMOVE_ZTXT))
                                                                            {
                                                                                text_ptr[ntext].key[0] = '\0';
                                                                                num_to_write--;
                                                                            }
                                                                        }
                                                                        if (text_ptr[ntext].compression == PNG_ITXT_COMPRESSION_NONE || text_ptr[ntext].compression == PNG_ITXT_COMPRESSION_zTXt)
                                                                        {
                                                                            if (Param2.getIntValue() & PNG_REMOVE_ITXT)
                                                                            {
                                                                                text_ptr[ntext].key[0] = '\0';
                                                                                num_to_write--;
                                                                            }
                                                                        }
                                                                    }
                                                                    if (num_to_write > 0)
                                                                    {
                                                                        png_set_text(write_ptr, write_end_info_ptr, text_ptr, num_text);
                                                                    }
                                                                }
                                                            }
                                                            for (ntext = 0; ntext < text_inputs; ntext++)
                                                            {
                                                                if (text_where[ntext] == 2)
                                                                {
                                                                    png_textp added_text;
                                                                    added_text = (png_textp)png_malloc(write_ptr, (png_uint_32)sizeof(png_text));
                                                                    added_text[0].key = &text_keyword[ntext * 80];
                                                                    added_text[0].lang = &text_lang[ntext * 80];
                                                                    added_text[0].lang_key = &text_lang_key[ntext * 80];
                                                                    added_text[0].text = &text_text[ntext * STR_BUF_SIZE];
                                                                    added_text[0].compression = text_compression[ntext];
                                                                    png_set_text(write_ptr, write_end_info_ptr, added_text, 1);
                                                                    png_free(write_ptr, added_text);
                                                                    added_text = (png_textp) NULL;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                //----------------[TIME]
                                                png_timep mod_time;
                                                if (png_get_tIME(read_ptr, end_info_ptr, &mod_time))
                                                {
                                                    if (!(Param2.getIntValue() & PNG_REMOVE_TIME))
                                                    {
                                                        png_set_tIME(write_ptr, write_end_info_ptr, mod_time);
                                                    }
                                                }
                                                //----------------[UNKN]
                                                png_unknown_chunkp unknowns;
                                                int num_unknowns = (int) png_get_unknown_chunks(read_ptr, end_info_ptr, &unknowns);
                                                if (num_unknowns)
                                                {
                                                    png_set_unknown_chunks(write_ptr, write_end_info_ptr, unknowns, num_unknowns);
                                                    for (i = 0; i < num_unknowns; i++)
                                                    {
                                                        png_set_unknown_chunk_location(write_ptr, write_end_info_ptr, i, (int)unknowns[i].location);
                                                    }
                                                }
                                            }
                                            png_write_end(write_ptr, write_end_info_ptr);
                                            png_free(read_ptr, row_buf);
                                            row_buf = (png_bytep) NULL;
                                            //record byte count for this trial round
                                            pngcrush_write_byte_count = pngOut.len;
                                            idat_length[trial] = pngcrush_write_byte_count;
                                            if (pngcrush_write_byte_count < pngcrush_best_byte_count)
                                            {
                                                pngcrush_best_byte_count = pngcrush_write_byte_count;
                                            }
                                            if (last_trial == 1)
                                            {
                                                //unless we have broken with the original image
                                                PA_Picture picture = PA_CreatePicture((void *)png.getBytesPtr(), png.getBytesLength());
                                                *(PA_Picture*) pResult = picture;
                                            }
                                            png_destroy_info_struct(write_ptr, &write_end_info_ptr);
                                            png_destroy_read_struct(&read_ptr, &read_info_ptr, &end_info_ptr);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
